{"ast":null,"code":"import get from 'es-toolkit/compat/get';\nimport { Children } from 'react';\nimport { isFragment } from 'react-is';\nimport { isNullish } from './DataUtils';\nexport var SCALE_TYPES = ['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'time', 'band', 'point', 'ordinal', 'quantile', 'quantize', 'utc', 'sequential', 'threshold'];\n\n/**\n * @deprecated instead find another approach that does not depend on displayName.\n * Get the display name of a component\n * @param  {Object} Comp Specified Component\n * @return {String}      Display name of Component\n */\nexport var getDisplayName = Comp => {\n  if (typeof Comp === 'string') {\n    return Comp;\n  }\n  if (!Comp) {\n    return '';\n  }\n  return Comp.displayName || Comp.name || 'Component';\n};\n\n// `toArray` gets called multiple times during the render\n// so we can memoize last invocation (since reference to `children` is the same)\nvar lastChildren = null;\nvar lastResult = null;\n\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * @param children do not use\n * @return deprecated do not use\n */\nexport var toArray = children => {\n  if (children === lastChildren && Array.isArray(lastResult)) {\n    return lastResult;\n  }\n  var result = [];\n  Children.forEach(children, child => {\n    if (isNullish(child)) return;\n    if (isFragment(child)) {\n      result = result.concat(toArray(child.props.children));\n    } else {\n      // @ts-expect-error this could still be Iterable<ReactNode> and TS does not like that\n      result.push(child);\n    }\n  });\n  lastResult = result;\n  lastChildren = children;\n  return result;\n};\n\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * Find and return all matched children by type.\n * `type` must be a React.ComponentType\n *\n * @param children do not use\n * @param type do not use\n * @return deprecated do not use\n */\nexport function findAllByType(children, type) {\n  var result = [];\n  var types = [];\n  if (Array.isArray(type)) {\n    types = type.map(t => getDisplayName(t));\n  } else {\n    types = [getDisplayName(type)];\n  }\n  toArray(children).forEach(child => {\n    // @ts-expect-error toArray and lodash.get are not compatible. Let's get rid of the whole findAllByType function\n    var childType = get(child, 'type.displayName') || get(child, 'type.name');\n    if (childType && types.indexOf(childType) !== -1) {\n      result.push(child);\n    }\n  });\n  return result;\n}\nexport var isClipDot = dot => {\n  if (dot && typeof dot === 'object' && 'clipDot' in dot) {\n    return Boolean(dot.clipDot);\n  }\n  return true;\n};","map":{"version":3,"names":["get","Children","isFragment","isNullish","SCALE_TYPES","getDisplayName","Comp","displayName","name","lastChildren","lastResult","toArray","children","Array","isArray","result","forEach","child","concat","props","push","findAllByType","type","types","map","t","childType","indexOf","isClipDot","dot","Boolean","clipDot"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/util/ReactUtils.js"],"sourcesContent":["import get from 'es-toolkit/compat/get';\nimport { Children } from 'react';\nimport { isFragment } from 'react-is';\nimport { isNullish } from './DataUtils';\nexport var SCALE_TYPES = ['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'time', 'band', 'point', 'ordinal', 'quantile', 'quantize', 'utc', 'sequential', 'threshold'];\n\n/**\n * @deprecated instead find another approach that does not depend on displayName.\n * Get the display name of a component\n * @param  {Object} Comp Specified Component\n * @return {String}      Display name of Component\n */\nexport var getDisplayName = Comp => {\n  if (typeof Comp === 'string') {\n    return Comp;\n  }\n  if (!Comp) {\n    return '';\n  }\n  return Comp.displayName || Comp.name || 'Component';\n};\n\n// `toArray` gets called multiple times during the render\n// so we can memoize last invocation (since reference to `children` is the same)\nvar lastChildren = null;\nvar lastResult = null;\n\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * @param children do not use\n * @return deprecated do not use\n */\nexport var toArray = children => {\n  if (children === lastChildren && Array.isArray(lastResult)) {\n    return lastResult;\n  }\n  var result = [];\n  Children.forEach(children, child => {\n    if (isNullish(child)) return;\n    if (isFragment(child)) {\n      result = result.concat(toArray(child.props.children));\n    } else {\n      // @ts-expect-error this could still be Iterable<ReactNode> and TS does not like that\n      result.push(child);\n    }\n  });\n  lastResult = result;\n  lastChildren = children;\n  return result;\n};\n\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * Find and return all matched children by type.\n * `type` must be a React.ComponentType\n *\n * @param children do not use\n * @param type do not use\n * @return deprecated do not use\n */\nexport function findAllByType(children, type) {\n  var result = [];\n  var types = [];\n  if (Array.isArray(type)) {\n    types = type.map(t => getDisplayName(t));\n  } else {\n    types = [getDisplayName(type)];\n  }\n  toArray(children).forEach(child => {\n    // @ts-expect-error toArray and lodash.get are not compatible. Let's get rid of the whole findAllByType function\n    var childType = get(child, 'type.displayName') || get(child, 'type.name');\n    if (childType && types.indexOf(childType) !== -1) {\n      result.push(child);\n    }\n  });\n  return result;\n}\nexport var isClipDot = dot => {\n  if (dot && typeof dot === 'object' && 'clipDot' in dot) {\n    return Boolean(dot.clipDot);\n  }\n  return true;\n};"],"mappings":"AAAA,OAAOA,GAAG,MAAM,uBAAuB;AACvC,SAASC,QAAQ,QAAQ,OAAO;AAChC,SAASC,UAAU,QAAQ,UAAU;AACrC,SAASC,SAAS,QAAQ,aAAa;AACvC,OAAO,IAAIC,WAAW,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,YAAY,EAAE,WAAW,CAAC;;AAE3K;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,cAAc,GAAGC,IAAI,IAAI;EAClC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOA,IAAI;EACb;EACA,IAAI,CAACA,IAAI,EAAE;IACT,OAAO,EAAE;EACX;EACA,OAAOA,IAAI,CAACC,WAAW,IAAID,IAAI,CAACE,IAAI,IAAI,WAAW;AACrD,CAAC;;AAED;AACA;AACA,IAAIC,YAAY,GAAG,IAAI;AACvB,IAAIC,UAAU,GAAG,IAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,OAAO,GAAGC,QAAQ,IAAI;EAC/B,IAAIA,QAAQ,KAAKH,YAAY,IAAII,KAAK,CAACC,OAAO,CAACJ,UAAU,CAAC,EAAE;IAC1D,OAAOA,UAAU;EACnB;EACA,IAAIK,MAAM,GAAG,EAAE;EACfd,QAAQ,CAACe,OAAO,CAACJ,QAAQ,EAAEK,KAAK,IAAI;IAClC,IAAId,SAAS,CAACc,KAAK,CAAC,EAAE;IACtB,IAAIf,UAAU,CAACe,KAAK,CAAC,EAAE;MACrBF,MAAM,GAAGA,MAAM,CAACG,MAAM,CAACP,OAAO,CAACM,KAAK,CAACE,KAAK,CAACP,QAAQ,CAAC,CAAC;IACvD,CAAC,MAAM;MACL;MACAG,MAAM,CAACK,IAAI,CAACH,KAAK,CAAC;IACpB;EACF,CAAC,CAAC;EACFP,UAAU,GAAGK,MAAM;EACnBN,YAAY,GAAGG,QAAQ;EACvB,OAAOG,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,aAAaA,CAACT,QAAQ,EAAEU,IAAI,EAAE;EAC5C,IAAIP,MAAM,GAAG,EAAE;EACf,IAAIQ,KAAK,GAAG,EAAE;EACd,IAAIV,KAAK,CAACC,OAAO,CAACQ,IAAI,CAAC,EAAE;IACvBC,KAAK,GAAGD,IAAI,CAACE,GAAG,CAACC,CAAC,IAAIpB,cAAc,CAACoB,CAAC,CAAC,CAAC;EAC1C,CAAC,MAAM;IACLF,KAAK,GAAG,CAAClB,cAAc,CAACiB,IAAI,CAAC,CAAC;EAChC;EACAX,OAAO,CAACC,QAAQ,CAAC,CAACI,OAAO,CAACC,KAAK,IAAI;IACjC;IACA,IAAIS,SAAS,GAAG1B,GAAG,CAACiB,KAAK,EAAE,kBAAkB,CAAC,IAAIjB,GAAG,CAACiB,KAAK,EAAE,WAAW,CAAC;IACzE,IAAIS,SAAS,IAAIH,KAAK,CAACI,OAAO,CAACD,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;MAChDX,MAAM,CAACK,IAAI,CAACH,KAAK,CAAC;IACpB;EACF,CAAC,CAAC;EACF,OAAOF,MAAM;AACf;AACA,OAAO,IAAIa,SAAS,GAAGC,GAAG,IAAI;EAC5B,IAAIA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAI,SAAS,IAAIA,GAAG,EAAE;IACtD,OAAOC,OAAO,CAACD,GAAG,CAACE,OAAO,CAAC;EAC7B;EACA,OAAO,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}