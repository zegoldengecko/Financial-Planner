{"ast":null,"code":"import { isVisible } from '../util/TickUtils';\nimport { getEveryNth } from '../util/getEveryNth';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  var result = (ticks || []).slice();\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  var _loop = function _loop() {\n      // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n      // If it can not, then increase the stepsize by 1, and try again.\n\n      var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n      // Break condition - If we have evaluated all the ticks, then we are done.\n      if (entry === undefined) {\n        return {\n          v: getEveryNth(ticks, stepsize)\n        };\n      }\n\n      // Check if the element collides with the next element\n      var i = index;\n      var size;\n      var getSize = () => {\n        if (size === undefined) {\n          size = getTickSize(entry, i);\n        }\n        return size;\n      };\n      var tickCoord = entry.coordinate;\n      // We will always show the first tick.\n      var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n      if (!isShow) {\n        // Start all over with a larger stepsize\n        index = 0;\n        start = initialStart;\n        stepsize += 1;\n      }\n      if (isShow) {\n        // If it can be shown, update the start\n        start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        index += stepsize;\n      }\n    },\n    _ret;\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return [];\n}\nexport function getEquidistantPreserveEndTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  // Reworked logic for getEquidistantPreserveEndTicks\n  var result = (ticks || []).slice();\n  var len = result.length;\n  if (len === 0) {\n    return [];\n  }\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n\n  // Start with stepsize = 1 (every tick) up to the maximum possible stepsize (len)\n  for (var stepsize = 1; stepsize <= len; stepsize++) {\n    // 1. Calculate the offset so the last tick (index len - 1) is always included in the sequence.\n    var offset = (len - 1) % stepsize;\n    var start = initialStart; // `start` tracks the coordinate of the last successfully drawn tick + gap\n    var ok = true;\n\n    // 2. Iterate through the end-anchored sequence: offset, offset + stepsize, ..., len - 1\n    var _loop2 = function _loop2() {\n        var entry = ticks[index];\n        if (entry == null) {\n          return 0; // continue\n        }\n        var i = index;\n        var size;\n\n        // Use a function to get size, as in the original code\n        var getSize = () => {\n          if (size === undefined) {\n            size = getTickSize(entry, i);\n          }\n          return size;\n        };\n        var tickCoord = entry.coordinate;\n\n        // 3. Apply visibility logic (including the first tick special case)\n        // The reviewer says *not* to unconditionally bypass checks for the last tick.\n        var isShow = index === offset || isVisible(sign, tickCoord, getSize, start, end);\n        if (!isShow) {\n          // If any tick in this end-anchored sequence fails visibility/collision,\n          // reject this stepsize and move to the next iteration (larger stepsize).\n          ok = false;\n          return 1; // break\n        }\n\n        // 4. If showable, update the 'start' coordinate for the next collision check\n        if (isShow) {\n          start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        }\n      },\n      _ret2;\n    for (var index = offset; index < len; index += stepsize) {\n      _ret2 = _loop2();\n      if (_ret2 === 0) continue;\n      if (_ret2 === 1) break;\n    }\n\n    // 5. If the entire sequence for this stepsize passed the visibility check, return the result\n    if (ok) {\n      // Build the final result array explicitly using the validated stepsize and offset.\n      var finalTicks = [];\n      for (var _index = offset; _index < len; _index += stepsize) {\n        var tick = ticks[_index];\n        if (tick != null) {\n          finalTicks.push(tick);\n        }\n      }\n      return finalTicks;\n    }\n  }\n\n  // If no stepsize works (this shouldn't happen unless minTickGap is huge), return an empty array.\n  return [];\n}","map":{"version":3,"names":["isVisible","getEveryNth","getEquidistantTicks","sign","boundaries","getTickSize","ticks","minTickGap","result","slice","start","initialStart","end","index","stepsize","_loop","entry","undefined","v","i","size","getSize","tickCoord","coordinate","isShow","_ret","length","getEquidistantPreserveEndTicks","len","offset","ok","_loop2","_ret2","finalTicks","_index","tick","push"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/cartesian/getEquidistantTicks.js"],"sourcesContent":["import { isVisible } from '../util/TickUtils';\nimport { getEveryNth } from '../util/getEveryNth';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  var result = (ticks || []).slice();\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n  var index = 0;\n  // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n  var stepsize = 1;\n  var start = initialStart;\n  var _loop = function _loop() {\n      // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n      // If it can not, then increase the stepsize by 1, and try again.\n\n      var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index];\n\n      // Break condition - If we have evaluated all the ticks, then we are done.\n      if (entry === undefined) {\n        return {\n          v: getEveryNth(ticks, stepsize)\n        };\n      }\n\n      // Check if the element collides with the next element\n      var i = index;\n      var size;\n      var getSize = () => {\n        if (size === undefined) {\n          size = getTickSize(entry, i);\n        }\n        return size;\n      };\n      var tickCoord = entry.coordinate;\n      // We will always show the first tick.\n      var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n      if (!isShow) {\n        // Start all over with a larger stepsize\n        index = 0;\n        start = initialStart;\n        stepsize += 1;\n      }\n      if (isShow) {\n        // If it can be shown, update the start\n        start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        index += stepsize;\n      }\n    },\n    _ret;\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return [];\n}\nexport function getEquidistantPreserveEndTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  // If the ticks are readonly, then the slice might not be necessary\n  // Reworked logic for getEquidistantPreserveEndTicks\n  var result = (ticks || []).slice();\n  var len = result.length;\n  if (len === 0) {\n    return [];\n  }\n  var {\n    start: initialStart,\n    end\n  } = boundaries;\n\n  // Start with stepsize = 1 (every tick) up to the maximum possible stepsize (len)\n  for (var stepsize = 1; stepsize <= len; stepsize++) {\n    // 1. Calculate the offset so the last tick (index len - 1) is always included in the sequence.\n    var offset = (len - 1) % stepsize;\n    var start = initialStart; // `start` tracks the coordinate of the last successfully drawn tick + gap\n    var ok = true;\n\n    // 2. Iterate through the end-anchored sequence: offset, offset + stepsize, ..., len - 1\n    var _loop2 = function _loop2() {\n        var entry = ticks[index];\n        if (entry == null) {\n          return 0; // continue\n        }\n        var i = index;\n        var size;\n\n        // Use a function to get size, as in the original code\n        var getSize = () => {\n          if (size === undefined) {\n            size = getTickSize(entry, i);\n          }\n          return size;\n        };\n        var tickCoord = entry.coordinate;\n\n        // 3. Apply visibility logic (including the first tick special case)\n        // The reviewer says *not* to unconditionally bypass checks for the last tick.\n        var isShow = index === offset || isVisible(sign, tickCoord, getSize, start, end);\n        if (!isShow) {\n          // If any tick in this end-anchored sequence fails visibility/collision,\n          // reject this stepsize and move to the next iteration (larger stepsize).\n          ok = false;\n          return 1; // break\n        }\n\n        // 4. If showable, update the 'start' coordinate for the next collision check\n        if (isShow) {\n          start = tickCoord + sign * (getSize() / 2 + minTickGap);\n        }\n      },\n      _ret2;\n    for (var index = offset; index < len; index += stepsize) {\n      _ret2 = _loop2();\n      if (_ret2 === 0) continue;\n      if (_ret2 === 1) break;\n    }\n\n    // 5. If the entire sequence for this stepsize passed the visibility check, return the result\n    if (ok) {\n      // Build the final result array explicitly using the validated stepsize and offset.\n      var finalTicks = [];\n      for (var _index = offset; _index < len; _index += stepsize) {\n        var tick = ticks[_index];\n        if (tick != null) {\n          finalTicks.push(tick);\n        }\n      }\n      return finalTicks;\n    }\n  }\n\n  // If no stepsize works (this shouldn't happen unless minTickGap is huge), return an empty array.\n  return [];\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}