{"ast":null,"code":"import { createAction, createListenerMiddleware } from '@reduxjs/toolkit';\nimport { selectActiveLabel, selectActiveTooltipCoordinate, selectActiveTooltipDataKey, selectActiveTooltipIndex, selectIsTooltipActive } from './selectors/tooltipSelectors';\nexport var externalEventAction = createAction('externalEvent');\nexport var externalEventsMiddleware = createListenerMiddleware();\n\n/*\n * We need a Map keyed by event type because this middleware handles MULTIPLE different event types\n * (click, mouseenter, mouseleave, mousedown, mouseup, contextmenu, dblclick, touchstart, touchmove, touchend)\n * from the same DOM element. Different event types should NOT cancel each other's animation frames.\n * For example, a click event and a mousemove event can happen in quick succession and both should be processed.\n * This is different from mouseMoveMiddleware which only handles one event type and uses a single rafId.\n */\nvar rafIdMap = new Map();\nexternalEventsMiddleware.startListening({\n  actionCreator: externalEventAction,\n  effect: (action, listenerApi) => {\n    var {\n      handler,\n      reactEvent\n    } = action.payload;\n    if (handler == null) {\n      return;\n    }\n    reactEvent.persist();\n    var eventType = reactEvent.type;\n\n    // Cancel any pending animation frame for this event type\n    var existingRafId = rafIdMap.get(eventType);\n    if (existingRafId !== undefined) {\n      cancelAnimationFrame(existingRafId);\n    }\n    var rafId = requestAnimationFrame(() => {\n      try {\n        /*\n         * Here it is important that we get the latest state inside the animation frame callback,\n         * not from the outer scope, because there may have been other actions dispatched\n         * between the time the event was fired and the animation frame callback is executed.\n         * One of those actions is the one that actually sets the active tooltip state!\n         */\n        var state = listenerApi.getState();\n        var nextState = {\n          activeCoordinate: selectActiveTooltipCoordinate(state),\n          activeDataKey: selectActiveTooltipDataKey(state),\n          activeIndex: selectActiveTooltipIndex(state),\n          activeLabel: selectActiveLabel(state),\n          activeTooltipIndex: selectActiveTooltipIndex(state),\n          isTooltipActive: selectIsTooltipActive(state)\n        };\n        handler(nextState, reactEvent);\n      } finally {\n        rafIdMap.delete(eventType);\n      }\n    });\n    rafIdMap.set(eventType, rafId);\n  }\n});","map":{"version":3,"names":["createAction","createListenerMiddleware","selectActiveLabel","selectActiveTooltipCoordinate","selectActiveTooltipDataKey","selectActiveTooltipIndex","selectIsTooltipActive","externalEventAction","externalEventsMiddleware","rafIdMap","Map","startListening","actionCreator","effect","action","listenerApi","handler","reactEvent","payload","persist","eventType","type","existingRafId","get","undefined","cancelAnimationFrame","rafId","requestAnimationFrame","state","getState","nextState","activeCoordinate","activeDataKey","activeIndex","activeLabel","activeTooltipIndex","isTooltipActive","delete","set"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/state/externalEventsMiddleware.js"],"sourcesContent":["import { createAction, createListenerMiddleware } from '@reduxjs/toolkit';\nimport { selectActiveLabel, selectActiveTooltipCoordinate, selectActiveTooltipDataKey, selectActiveTooltipIndex, selectIsTooltipActive } from './selectors/tooltipSelectors';\nexport var externalEventAction = createAction('externalEvent');\nexport var externalEventsMiddleware = createListenerMiddleware();\n\n/*\n * We need a Map keyed by event type because this middleware handles MULTIPLE different event types\n * (click, mouseenter, mouseleave, mousedown, mouseup, contextmenu, dblclick, touchstart, touchmove, touchend)\n * from the same DOM element. Different event types should NOT cancel each other's animation frames.\n * For example, a click event and a mousemove event can happen in quick succession and both should be processed.\n * This is different from mouseMoveMiddleware which only handles one event type and uses a single rafId.\n */\nvar rafIdMap = new Map();\nexternalEventsMiddleware.startListening({\n  actionCreator: externalEventAction,\n  effect: (action, listenerApi) => {\n    var {\n      handler,\n      reactEvent\n    } = action.payload;\n    if (handler == null) {\n      return;\n    }\n    reactEvent.persist();\n    var eventType = reactEvent.type;\n\n    // Cancel any pending animation frame for this event type\n    var existingRafId = rafIdMap.get(eventType);\n    if (existingRafId !== undefined) {\n      cancelAnimationFrame(existingRafId);\n    }\n    var rafId = requestAnimationFrame(() => {\n      try {\n        /*\n         * Here it is important that we get the latest state inside the animation frame callback,\n         * not from the outer scope, because there may have been other actions dispatched\n         * between the time the event was fired and the animation frame callback is executed.\n         * One of those actions is the one that actually sets the active tooltip state!\n         */\n        var state = listenerApi.getState();\n        var nextState = {\n          activeCoordinate: selectActiveTooltipCoordinate(state),\n          activeDataKey: selectActiveTooltipDataKey(state),\n          activeIndex: selectActiveTooltipIndex(state),\n          activeLabel: selectActiveLabel(state),\n          activeTooltipIndex: selectActiveTooltipIndex(state),\n          isTooltipActive: selectIsTooltipActive(state)\n        };\n        handler(nextState, reactEvent);\n      } finally {\n        rafIdMap.delete(eventType);\n      }\n    });\n    rafIdMap.set(eventType, rafId);\n  }\n});"],"mappings":"AAAA,SAASA,YAAY,EAAEC,wBAAwB,QAAQ,kBAAkB;AACzE,SAASC,iBAAiB,EAAEC,6BAA6B,EAAEC,0BAA0B,EAAEC,wBAAwB,EAAEC,qBAAqB,QAAQ,8BAA8B;AAC5K,OAAO,IAAIC,mBAAmB,GAAGP,YAAY,CAAC,eAAe,CAAC;AAC9D,OAAO,IAAIQ,wBAAwB,GAAGP,wBAAwB,CAAC,CAAC;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIQ,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;AACxBF,wBAAwB,CAACG,cAAc,CAAC;EACtCC,aAAa,EAAEL,mBAAmB;EAClCM,MAAM,EAAEA,CAACC,MAAM,EAAEC,WAAW,KAAK;IAC/B,IAAI;MACFC,OAAO;MACPC;IACF,CAAC,GAAGH,MAAM,CAACI,OAAO;IAClB,IAAIF,OAAO,IAAI,IAAI,EAAE;MACnB;IACF;IACAC,UAAU,CAACE,OAAO,CAAC,CAAC;IACpB,IAAIC,SAAS,GAAGH,UAAU,CAACI,IAAI;;IAE/B;IACA,IAAIC,aAAa,GAAGb,QAAQ,CAACc,GAAG,CAACH,SAAS,CAAC;IAC3C,IAAIE,aAAa,KAAKE,SAAS,EAAE;MAC/BC,oBAAoB,CAACH,aAAa,CAAC;IACrC;IACA,IAAII,KAAK,GAAGC,qBAAqB,CAAC,MAAM;MACtC,IAAI;QACF;AACR;AACA;AACA;AACA;AACA;QACQ,IAAIC,KAAK,GAAGb,WAAW,CAACc,QAAQ,CAAC,CAAC;QAClC,IAAIC,SAAS,GAAG;UACdC,gBAAgB,EAAE5B,6BAA6B,CAACyB,KAAK,CAAC;UACtDI,aAAa,EAAE5B,0BAA0B,CAACwB,KAAK,CAAC;UAChDK,WAAW,EAAE5B,wBAAwB,CAACuB,KAAK,CAAC;UAC5CM,WAAW,EAAEhC,iBAAiB,CAAC0B,KAAK,CAAC;UACrCO,kBAAkB,EAAE9B,wBAAwB,CAACuB,KAAK,CAAC;UACnDQ,eAAe,EAAE9B,qBAAqB,CAACsB,KAAK;QAC9C,CAAC;QACDZ,OAAO,CAACc,SAAS,EAAEb,UAAU,CAAC;MAChC,CAAC,SAAS;QACRR,QAAQ,CAAC4B,MAAM,CAACjB,SAAS,CAAC;MAC5B;IACF,CAAC,CAAC;IACFX,QAAQ,CAAC6B,GAAG,CAAClB,SAAS,EAAEM,KAAK,CAAC;EAChC;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}