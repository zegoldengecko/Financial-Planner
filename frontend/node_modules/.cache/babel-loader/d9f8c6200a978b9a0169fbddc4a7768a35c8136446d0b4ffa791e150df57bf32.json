{"ast":null,"code":"var _excluded = [\"x\", \"y\"];\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nimport { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectEventEmitter, selectSyncId, selectSyncMethod } from '../state/selectors/rootPropsSelectors';\nimport { BRUSH_SYNC_EVENT, eventCenter, TOOLTIP_SYNC_EVENT } from '../util/Events';\nimport { createEventEmitter } from '../state/optionsSlice';\nimport { setSyncInteraction } from '../state/tooltipSlice';\nimport { selectTooltipDataKey } from '../state/selectors/selectors';\nimport { selectTooltipAxisTicks } from '../state/selectors/tooltipSelectors';\nimport { selectSynchronisedTooltipState } from './syncSelectors';\nimport { useChartLayout, useViewBox } from '../context/chartLayoutContext';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\nimport { noop } from '../util/DataUtils';\nfunction useTooltipSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);\n  var layout = useChartLayout();\n  var viewBox = useViewBox();\n  var className = useAppSelector(state => state.rootProps.className);\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId !== incomingSyncId) {\n        // This event is not for this chart\n        return;\n      }\n      if (syncMethod === 'index') {\n        var _action$payload;\n        if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {\n          var _action$payload$coord = action.payload.coordinate,\n            {\n              x: _x,\n              y: _y\n            } = _action$payload$coord,\n            otherCoordinateProps = _objectWithoutProperties(_action$payload$coord, _excluded);\n          var {\n            x: sourceX,\n            y: sourceY,\n            width: sourceWidth,\n            height: sourceHeight\n          } = action.payload.sourceViewBox;\n          var scaledCoordinate = _objectSpread(_objectSpread({}, otherCoordinateProps), {}, {\n            x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,\n            y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height\n          });\n          dispatch(_objectSpread(_objectSpread({}, action), {}, {\n            payload: _objectSpread(_objectSpread({}, action.payload), {}, {\n              coordinate: scaledCoordinate\n            })\n          }));\n        } else {\n          dispatch(action);\n        }\n        return;\n      }\n      if (tooltipTicks == null) {\n        // for the other two sync methods, we need the ticks to be available\n        return;\n      }\n      var activeTick;\n      if (typeof syncMethod === 'function') {\n        /*\n         * This is what the data shape in 2.x CategoricalChartState used to look like.\n         * In 3.x we store things differently but let's try to keep the old shape for compatibility.\n         */\n        var syncMethodParam = {\n          activeTooltipIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          isTooltipActive: action.payload.active,\n          activeIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          activeLabel: action.payload.label,\n          activeDataKey: action.payload.dataKey,\n          activeCoordinate: action.payload.coordinate\n        };\n        // Call a callback function. If there is an application specific algorithm\n        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);\n        activeTick = tooltipTicks[activeTooltipIndex];\n      } else if (syncMethod === 'value') {\n        // labels are always strings, tick.value might be a string or a number, depending on axis type\n        activeTick = tooltipTicks.find(tick => String(tick.value) === action.payload.label);\n      }\n      var {\n        coordinate\n      } = action.payload;\n      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {\n        dispatch(setSyncInteraction({\n          active: false,\n          coordinate: undefined,\n          dataKey: undefined,\n          index: null,\n          label: undefined,\n          sourceViewBox: undefined,\n          graphicalItemId: undefined\n        }));\n        return;\n      }\n      var {\n        x,\n        y\n      } = coordinate;\n      var validateChartX = Math.min(x, viewBox.x + viewBox.width);\n      var validateChartY = Math.min(y, viewBox.y + viewBox.height);\n      var activeCoordinate = {\n        x: layout === 'horizontal' ? activeTick.coordinate : validateChartX,\n        y: layout === 'horizontal' ? validateChartY : activeTick.coordinate\n      };\n      var syncAction = setSyncInteraction({\n        active: action.payload.active,\n        coordinate: activeCoordinate,\n        dataKey: action.payload.dataKey,\n        index: String(activeTick.index),\n        label: action.payload.label,\n        sourceViewBox: action.payload.sourceViewBox,\n        graphicalItemId: action.payload.graphicalItemId\n      });\n      dispatch(syncAction);\n    };\n    eventCenter.on(TOOLTIP_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(TOOLTIP_SYNC_EVENT, listener);\n    };\n  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);\n}\nfunction useBrushSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId === incomingSyncId) {\n        dispatch(setDataStartEndIndexes(action));\n      }\n    };\n    eventCenter.on(BRUSH_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(BRUSH_SYNC_EVENT, listener);\n    };\n  }, [dispatch, myEventEmitter, mySyncId]);\n}\n\n/**\n * Will receive synchronisation events from other charts.\n *\n * Reads syncMethod from state and decides how to synchronise the tooltip based on that.\n *\n * @returns void\n */\nexport function useSynchronisedEventsFromOtherCharts() {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(createEventEmitter());\n  }, [dispatch]);\n  useTooltipSyncEventsListener();\n  useBrushSyncEventsListener();\n}\n\n/**\n * Will send events to other charts.\n * If syncId is undefined, no events will be sent.\n *\n * This ignores the syncMethod, because that is set and computed on the receiving end.\n *\n * @param tooltipEventType from Tooltip\n * @param trigger from Tooltip\n * @param activeCoordinate from state\n * @param activeLabel from state\n * @param activeIndex from state\n * @param isTooltipActive from state\n * @returns void\n */\nexport function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {\n  var activeDataKey = useAppSelector(state => selectTooltipDataKey(state, tooltipEventType, trigger));\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var syncId = useAppSelector(selectSyncId);\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipState = useAppSelector(selectSynchronisedTooltipState);\n  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;\n  var viewBox = useViewBox();\n  useEffect(() => {\n    if (isReceivingSynchronisation) {\n      /*\n       * This chart currently has active tooltip, synchronised from another chart.\n       * Let's not send any outgoing synchronisation events while that's happening\n       * to avoid infinite loops.\n       */\n      return;\n    }\n    if (syncId == null) {\n      /*\n       * syncId is not set, means that this chart is not synchronised with any other chart,\n       * means we don't need to send synchronisation events\n       */\n      return;\n    }\n    if (eventEmitterSymbol == null) {\n      /*\n       * When using Recharts internal hooks and selectors outside charts context,\n       * these properties will be undefined. Let's return silently instead of throwing an error.\n       */\n      return;\n    }\n    var syncAction = setSyncInteraction({\n      active: isTooltipActive,\n      coordinate: activeCoordinate,\n      dataKey: activeDataKey,\n      index: activeIndex,\n      label: typeof activeLabel === 'number' ? String(activeLabel) : activeLabel,\n      sourceViewBox: viewBox,\n      graphicalItemId: undefined\n    });\n    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive, viewBox]);\n}\nexport function useBrushChartSynchronisation() {\n  var syncId = useAppSelector(selectSyncId);\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var brushStartIndex = useAppSelector(state => state.chartData.dataStartIndex);\n  var brushEndIndex = useAppSelector(state => state.chartData.dataEndIndex);\n  useEffect(() => {\n    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {\n      return;\n    }\n    var syncAction = {\n      startIndex: brushStartIndex,\n      endIndex: brushEndIndex\n    };\n    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);\n}","map":{"version":3,"names":["_excluded","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","_objectWithoutProperties","_objectWithoutPropertiesLoose","n","indexOf","propertyIsEnumerable","hasOwnProperty","useEffect","useAppDispatch","useAppSelector","selectEventEmitter","selectSyncId","selectSyncMethod","BRUSH_SYNC_EVENT","eventCenter","TOOLTIP_SYNC_EVENT","createEventEmitter","setSyncInteraction","selectTooltipDataKey","selectTooltipAxisTicks","selectSynchronisedTooltipState","useChartLayout","useViewBox","setDataStartEndIndexes","noop","useTooltipSyncEventsListener","mySyncId","myEventEmitter","dispatch","syncMethod","tooltipTicks","layout","viewBox","className","state","rootProps","listener","incomingSyncId","action","emitter","_action$payload","payload","coordinate","sourceViewBox","_action$payload$coord","x","_x","y","_y","otherCoordinateProps","sourceX","sourceY","width","sourceWidth","height","sourceHeight","scaledCoordinate","activeTick","syncMethodParam","activeTooltipIndex","index","undefined","isTooltipActive","active","activeIndex","activeLabel","label","activeDataKey","dataKey","activeCoordinate","find","tick","graphicalItemId","validateChartX","Math","min","validateChartY","syncAction","on","off","useBrushSyncEventsListener","useSynchronisedEventsFromOtherCharts","useTooltipChartSynchronisation","tooltipEventType","trigger","eventEmitterSymbol","syncId","tooltipState","isReceivingSynchronisation","emit","useBrushChartSynchronisation","brushStartIndex","chartData","dataStartIndex","brushEndIndex","dataEndIndex","startIndex","endIndex"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/synchronisation/useChartSynchronisation.js"],"sourcesContent":["var _excluded = [\"x\", \"y\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nimport { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectEventEmitter, selectSyncId, selectSyncMethod } from '../state/selectors/rootPropsSelectors';\nimport { BRUSH_SYNC_EVENT, eventCenter, TOOLTIP_SYNC_EVENT } from '../util/Events';\nimport { createEventEmitter } from '../state/optionsSlice';\nimport { setSyncInteraction } from '../state/tooltipSlice';\nimport { selectTooltipDataKey } from '../state/selectors/selectors';\nimport { selectTooltipAxisTicks } from '../state/selectors/tooltipSelectors';\nimport { selectSynchronisedTooltipState } from './syncSelectors';\nimport { useChartLayout, useViewBox } from '../context/chartLayoutContext';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\nimport { noop } from '../util/DataUtils';\nfunction useTooltipSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);\n  var layout = useChartLayout();\n  var viewBox = useViewBox();\n  var className = useAppSelector(state => state.rootProps.className);\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId !== incomingSyncId) {\n        // This event is not for this chart\n        return;\n      }\n      if (syncMethod === 'index') {\n        var _action$payload;\n        if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {\n          var _action$payload$coord = action.payload.coordinate,\n            {\n              x: _x,\n              y: _y\n            } = _action$payload$coord,\n            otherCoordinateProps = _objectWithoutProperties(_action$payload$coord, _excluded);\n          var {\n            x: sourceX,\n            y: sourceY,\n            width: sourceWidth,\n            height: sourceHeight\n          } = action.payload.sourceViewBox;\n          var scaledCoordinate = _objectSpread(_objectSpread({}, otherCoordinateProps), {}, {\n            x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,\n            y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height\n          });\n          dispatch(_objectSpread(_objectSpread({}, action), {}, {\n            payload: _objectSpread(_objectSpread({}, action.payload), {}, {\n              coordinate: scaledCoordinate\n            })\n          }));\n        } else {\n          dispatch(action);\n        }\n        return;\n      }\n      if (tooltipTicks == null) {\n        // for the other two sync methods, we need the ticks to be available\n        return;\n      }\n      var activeTick;\n      if (typeof syncMethod === 'function') {\n        /*\n         * This is what the data shape in 2.x CategoricalChartState used to look like.\n         * In 3.x we store things differently but let's try to keep the old shape for compatibility.\n         */\n        var syncMethodParam = {\n          activeTooltipIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          isTooltipActive: action.payload.active,\n          activeIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          activeLabel: action.payload.label,\n          activeDataKey: action.payload.dataKey,\n          activeCoordinate: action.payload.coordinate\n        };\n        // Call a callback function. If there is an application specific algorithm\n        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);\n        activeTick = tooltipTicks[activeTooltipIndex];\n      } else if (syncMethod === 'value') {\n        // labels are always strings, tick.value might be a string or a number, depending on axis type\n        activeTick = tooltipTicks.find(tick => String(tick.value) === action.payload.label);\n      }\n      var {\n        coordinate\n      } = action.payload;\n      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {\n        dispatch(setSyncInteraction({\n          active: false,\n          coordinate: undefined,\n          dataKey: undefined,\n          index: null,\n          label: undefined,\n          sourceViewBox: undefined,\n          graphicalItemId: undefined\n        }));\n        return;\n      }\n      var {\n        x,\n        y\n      } = coordinate;\n      var validateChartX = Math.min(x, viewBox.x + viewBox.width);\n      var validateChartY = Math.min(y, viewBox.y + viewBox.height);\n      var activeCoordinate = {\n        x: layout === 'horizontal' ? activeTick.coordinate : validateChartX,\n        y: layout === 'horizontal' ? validateChartY : activeTick.coordinate\n      };\n      var syncAction = setSyncInteraction({\n        active: action.payload.active,\n        coordinate: activeCoordinate,\n        dataKey: action.payload.dataKey,\n        index: String(activeTick.index),\n        label: action.payload.label,\n        sourceViewBox: action.payload.sourceViewBox,\n        graphicalItemId: action.payload.graphicalItemId\n      });\n      dispatch(syncAction);\n    };\n    eventCenter.on(TOOLTIP_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(TOOLTIP_SYNC_EVENT, listener);\n    };\n  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);\n}\nfunction useBrushSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId === incomingSyncId) {\n        dispatch(setDataStartEndIndexes(action));\n      }\n    };\n    eventCenter.on(BRUSH_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(BRUSH_SYNC_EVENT, listener);\n    };\n  }, [dispatch, myEventEmitter, mySyncId]);\n}\n\n/**\n * Will receive synchronisation events from other charts.\n *\n * Reads syncMethod from state and decides how to synchronise the tooltip based on that.\n *\n * @returns void\n */\nexport function useSynchronisedEventsFromOtherCharts() {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(createEventEmitter());\n  }, [dispatch]);\n  useTooltipSyncEventsListener();\n  useBrushSyncEventsListener();\n}\n\n/**\n * Will send events to other charts.\n * If syncId is undefined, no events will be sent.\n *\n * This ignores the syncMethod, because that is set and computed on the receiving end.\n *\n * @param tooltipEventType from Tooltip\n * @param trigger from Tooltip\n * @param activeCoordinate from state\n * @param activeLabel from state\n * @param activeIndex from state\n * @param isTooltipActive from state\n * @returns void\n */\nexport function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {\n  var activeDataKey = useAppSelector(state => selectTooltipDataKey(state, tooltipEventType, trigger));\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var syncId = useAppSelector(selectSyncId);\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipState = useAppSelector(selectSynchronisedTooltipState);\n  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;\n  var viewBox = useViewBox();\n  useEffect(() => {\n    if (isReceivingSynchronisation) {\n      /*\n       * This chart currently has active tooltip, synchronised from another chart.\n       * Let's not send any outgoing synchronisation events while that's happening\n       * to avoid infinite loops.\n       */\n      return;\n    }\n    if (syncId == null) {\n      /*\n       * syncId is not set, means that this chart is not synchronised with any other chart,\n       * means we don't need to send synchronisation events\n       */\n      return;\n    }\n    if (eventEmitterSymbol == null) {\n      /*\n       * When using Recharts internal hooks and selectors outside charts context,\n       * these properties will be undefined. Let's return silently instead of throwing an error.\n       */\n      return;\n    }\n    var syncAction = setSyncInteraction({\n      active: isTooltipActive,\n      coordinate: activeCoordinate,\n      dataKey: activeDataKey,\n      index: activeIndex,\n      label: typeof activeLabel === 'number' ? String(activeLabel) : activeLabel,\n      sourceViewBox: viewBox,\n      graphicalItemId: undefined\n    });\n    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive, viewBox]);\n}\nexport function useBrushChartSynchronisation() {\n  var syncId = useAppSelector(selectSyncId);\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var brushStartIndex = useAppSelector(state => state.chartData.dataStartIndex);\n  var brushEndIndex = useAppSelector(state => state.chartData.dataEndIndex);\n  useEffect(() => {\n    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {\n      return;\n    }\n    var syncAction = {\n      startIndex: brushStartIndex,\n      endIndex: brushEndIndex\n    };\n    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}