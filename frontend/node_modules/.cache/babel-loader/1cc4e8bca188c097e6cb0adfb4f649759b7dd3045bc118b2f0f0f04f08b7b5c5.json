{"ast":null,"code":"import { spendingTypeMap, MIN_TRANSACTION_AMOUNT, MAX_TRANSACTION_AMOUNT, MIN_YEAR, MAX_YEAR, SPENDING_TYPE_DISCRETIONARY, SPENDING_TYPE_NON_DISCRETIONARY, SPENDING_TYPE_NULL, EMERGENCY_FUND_MULTIPLIER, PERCENT_MULTIPLIER, DATE_REGEX } from \"./constants.js\";\n\n// Validating the new transaction\nexport const validateTransaction = ({\n  type,\n  category,\n  amount,\n  date\n}) => {\n  if (!type || !category || !amount || !date) return \"Required fields are empty\";\n  const numericAmount = parseFloat(String(amount).replace(/[$,]/g, \"\"));\n  if (isNaN(numericAmount) || numericAmount <= MIN_TRANSACTION_AMOUNT || numericAmount >= MAX_TRANSACTION_AMOUNT) {\n    return `Invalid amount. Must be between $${MIN_TRANSACTION_AMOUNT} and $${MAX_TRANSACTION_AMOUNT.toLocaleString()}.`;\n  }\n  if (!DATE_REGEX.test(date)) return \"Invalid date.\";\n  const year = parseInt(date.split(\"/\")[2], 10);\n  if (year < MIN_YEAR || year > MAX_YEAR) return `Year must be between ${MIN_YEAR} and ${MAX_YEAR}.`;\n  return null;\n};\n\n// Getting the spending type\nexport const getSpendingType = category => {\n  if (spendingTypeMap.discretionary.includes(category)) return SPENDING_TYPE_DISCRETIONARY;\n  if (spendingTypeMap.nonDiscretionary.includes(category)) return SPENDING_TYPE_NON_DISCRETIONARY;\n  return SPENDING_TYPE_NULL;\n};\n\n// Calculating financial statistics\nexport function calculateStats({\n  totalIncome,\n  totalExpenses,\n  prevIncome,\n  prevExpenses,\n  totalSavings,\n  periodTransactions\n}) {\n  const emergencyFund = totalExpenses * EMERGENCY_FUND_MULTIPLIER;\n  const incomeChange = totalIncome - prevIncome;\n  const incomeChangePercent = prevIncome !== 0 ? (incomeChange / prevIncome * PERCENT_MULTIPLIER).toFixed(0) : 0;\n  const expenseChange = totalExpenses - prevExpenses;\n  const expenseChangePercent = prevExpenses !== 0 ? (expenseChange / prevExpenses * PERCENT_MULTIPLIER).toFixed(0) : 0;\n  const periodCashflow = periodTransactions.map(item => ({\n    period: item.period,\n    net: item.income - item.expense\n  }));\n  const periodIncome = periodTransactions.map(item => ({\n    period: item.period,\n    income: item.income\n  }));\n  const periodExpenses = periodTransactions.map(item => ({\n    period: item.period,\n    expense: item.expense\n  }));\n  const savingsRate = totalIncome > 0 ? ((totalIncome - totalExpenses) / totalIncome * PERCENT_MULTIPLIER).toFixed(2) : 0;\n  const EIRatio = totalIncome > 0 ? (totalExpenses / totalIncome).toFixed(2) : 0;\n  const runway = totalExpenses > 0 ? Math.floor(totalSavings / totalExpenses) : 0;\n  return {\n    emergencyFund,\n    incomeChange,\n    incomeChangePercent,\n    expenseChange,\n    expenseChangePercent,\n    periodCashflow,\n    periodIncome,\n    periodExpenses,\n    savingsRate,\n    EIRatio,\n    runway\n  };\n}\n\n// Adding a transaction to a database\nexport async function addTransaction({\n  typeOption,\n  categoryOption,\n  amountValue,\n  dateValue,\n  descriptionValue,\n  setError,\n  setSuccess,\n  updateDateView\n}) {\n  setError(\"\");\n  setSuccess(\"\");\n\n  // Validate inputs\n  const errorMsg = validateTransaction({\n    type: typeOption,\n    category: categoryOption,\n    amount: amountValue,\n    date: dateValue\n  });\n  if (errorMsg) {\n    setError(errorMsg);\n    return;\n  }\n  const amount = parseFloat(amountValue.replace(/[$,]/g, \"\"));\n  const spending = getSpendingType(categoryOption);\n  try {\n    const response = await fetch(\"http://localhost:5000/api/add\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      credentials: \"include\",\n      body: JSON.stringify({\n        type: typeOption,\n        category: categoryOption,\n        spendingType: spending,\n        amount,\n        date: dateValue,\n        description: descriptionValue\n      })\n    });\n    const data = await response.json();\n    if (!response.ok) {\n      alert(data.message || \"Adding transaction failed\");\n      return;\n    }\n    setSuccess(\"Added Transaction!\");\n    return {\n      reset: true,\n      updateDateView\n    };\n  } catch (err) {\n    console.error(\"Error adding transaction:\", err);\n    setError(\"Network error.\");\n  }\n}","map":{"version":3,"names":["spendingTypeMap","MIN_TRANSACTION_AMOUNT","MAX_TRANSACTION_AMOUNT","MIN_YEAR","MAX_YEAR","SPENDING_TYPE_DISCRETIONARY","SPENDING_TYPE_NON_DISCRETIONARY","SPENDING_TYPE_NULL","EMERGENCY_FUND_MULTIPLIER","PERCENT_MULTIPLIER","DATE_REGEX","validateTransaction","type","category","amount","date","numericAmount","parseFloat","String","replace","isNaN","toLocaleString","test","year","parseInt","split","getSpendingType","discretionary","includes","nonDiscretionary","calculateStats","totalIncome","totalExpenses","prevIncome","prevExpenses","totalSavings","periodTransactions","emergencyFund","incomeChange","incomeChangePercent","toFixed","expenseChange","expenseChangePercent","periodCashflow","map","item","period","net","income","expense","periodIncome","periodExpenses","savingsRate","EIRatio","runway","Math","floor","addTransaction","typeOption","categoryOption","amountValue","dateValue","descriptionValue","setError","setSuccess","updateDateView","errorMsg","spending","response","fetch","method","headers","credentials","body","JSON","stringify","spendingType","description","data","json","ok","alert","message","reset","err","console","error"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/src/utils/plannerHelpers.js"],"sourcesContent":["import { \r\n  spendingTypeMap,\r\n  MIN_TRANSACTION_AMOUNT,\r\n  MAX_TRANSACTION_AMOUNT,\r\n  MIN_YEAR,\r\n  MAX_YEAR,\r\n  SPENDING_TYPE_DISCRETIONARY,\r\n  SPENDING_TYPE_NON_DISCRETIONARY,\r\n  SPENDING_TYPE_NULL,\r\n  EMERGENCY_FUND_MULTIPLIER,\r\n  PERCENT_MULTIPLIER,\r\n  DATE_REGEX\r\n} from \"./constants.js\";\r\n\r\n// Validating the new transaction\r\nexport const validateTransaction = ({ type, category, amount, date }) => {\r\n  if (!type || !category || !amount || !date) return \"Required fields are empty\";\r\n\r\n  const numericAmount = parseFloat(String(amount).replace(/[$,]/g, \"\"));\r\n  if (isNaN(numericAmount) || numericAmount <= MIN_TRANSACTION_AMOUNT || numericAmount >= MAX_TRANSACTION_AMOUNT) {\r\n    return `Invalid amount. Must be between $${MIN_TRANSACTION_AMOUNT} and $${MAX_TRANSACTION_AMOUNT.toLocaleString()}.`;\r\n  }\r\n\r\n  if (!DATE_REGEX.test(date)) return \"Invalid date.\";\r\n\r\n  const year = parseInt(date.split(\"/\")[2], 10);\r\n  if (year < MIN_YEAR || year > MAX_YEAR) return `Year must be between ${MIN_YEAR} and ${MAX_YEAR}.`;\r\n\r\n  return null;\r\n};\r\n\r\n// Getting the spending type\r\nexport const getSpendingType = (category) => {\r\n  if (spendingTypeMap.discretionary.includes(category)) return SPENDING_TYPE_DISCRETIONARY;\r\n  if (spendingTypeMap.nonDiscretionary.includes(category)) return SPENDING_TYPE_NON_DISCRETIONARY;\r\n  return SPENDING_TYPE_NULL;\r\n};\r\n\r\n// Calculating financial statistics\r\nexport function calculateStats({ totalIncome, totalExpenses, prevIncome, prevExpenses, totalSavings, periodTransactions }) {\r\n  const emergencyFund = totalExpenses * EMERGENCY_FUND_MULTIPLIER;\r\n\r\n  const incomeChange = totalIncome - prevIncome;\r\n  const incomeChangePercent = prevIncome !== 0 ? ((incomeChange / prevIncome) * PERCENT_MULTIPLIER).toFixed(0) : 0;\r\n\r\n  const expenseChange = totalExpenses - prevExpenses;\r\n  const expenseChangePercent = prevExpenses !== 0 ? ((expenseChange / prevExpenses) * PERCENT_MULTIPLIER).toFixed(0) : 0;\r\n\r\n  const periodCashflow = periodTransactions.map(item => ({\r\n    period: item.period,\r\n    net: item.income - item.expense\r\n  }));\r\n\r\n  const periodIncome = periodTransactions.map(item => ({\r\n    period: item.period,\r\n    income: item.income\r\n  }));\r\n\r\n  const periodExpenses = periodTransactions.map(item => ({\r\n    period: item.period,\r\n    expense: item.expense\r\n  }));\r\n\r\n  const savingsRate = totalIncome > 0 ? (((totalIncome - totalExpenses) / totalIncome) * PERCENT_MULTIPLIER).toFixed(2) : 0;\r\n  const EIRatio = totalIncome > 0 ? (totalExpenses / totalIncome).toFixed(2) : 0;\r\n  const runway = totalExpenses > 0 ? Math.floor(totalSavings / totalExpenses) : 0;\r\n\r\n  return {\r\n    emergencyFund,\r\n    incomeChange,\r\n    incomeChangePercent,\r\n    expenseChange,\r\n    expenseChangePercent,\r\n    periodCashflow,\r\n    periodIncome,\r\n    periodExpenses,\r\n    savingsRate,\r\n    EIRatio,\r\n    runway\r\n  };\r\n}\r\n\r\n// Adding a transaction to a database\r\nexport async function addTransaction({ typeOption, categoryOption, amountValue, dateValue, descriptionValue, setError, setSuccess, updateDateView }) {\r\n  setError(\"\");\r\n  setSuccess(\"\");\r\n\r\n  // Validate inputs\r\n  const errorMsg = validateTransaction({ type: typeOption, category: categoryOption, amount: amountValue, date: dateValue });\r\n  if (errorMsg) {\r\n    setError(errorMsg);\r\n    return;\r\n  }\r\n\r\n  const amount = parseFloat(amountValue.replace(/[$,]/g, \"\"));\r\n  const spending = getSpendingType(categoryOption);\r\n\r\n  try {\r\n    const response = await fetch(\"http://localhost:5000/api/add\", {\r\n      method: \"POST\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      credentials: \"include\",\r\n      body: JSON.stringify({ type: typeOption, category: categoryOption, spendingType: spending, amount, date: dateValue, description: descriptionValue }),\r\n    });\r\n\r\n    const data = await response.json();\r\n\r\n    if (!response.ok) {\r\n      alert(data.message || \"Adding transaction failed\");\r\n      return;\r\n    }\r\n\r\n    setSuccess(\"Added Transaction!\");\r\n    return { reset: true, updateDateView };\r\n  } catch (err) {\r\n    console.error(\"Error adding transaction:\", err);\r\n    setError(\"Network error.\");\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}