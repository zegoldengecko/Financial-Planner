{"ast":null,"code":"import get from 'es-toolkit/compat/get';\nimport { round } from './round';\nexport var mathSign = value => {\n  if (value === 0) {\n    return 0;\n  }\n  if (value > 0) {\n    return 1;\n  }\n  return -1;\n};\nexport var isNan = value => {\n  // eslint-disable-next-line eqeqeq\n  return typeof value == 'number' && value != +value;\n};\nexport var isPercent = value => typeof value === 'string' && value.indexOf('%') === value.length - 1;\nexport var isNumber = value => (typeof value === 'number' || value instanceof Number) && !isNan(value);\nexport var isNumOrStr = value => isNumber(value) || typeof value === 'string';\nvar idCounter = 0;\nexport var uniqueId = prefix => {\n  var id = ++idCounter;\n  return \"\".concat(prefix || '').concat(id);\n};\n\n/**\n * Calculates the numeric value represented by a percent string or number, based on a total value.\n *\n * - If `percent` is not a number or string, returns `defaultValue`.\n * - If `percent` is a percent string but `totalValue` is null/undefined, returns `defaultValue`.\n * - If the result is NaN, returns `defaultValue`.\n * - If `validate` is true and the result exceeds `totalValue`, returns `totalValue`.\n *\n * @param percent - The percent value to convert. Can be a number (e.g. 25) or a string ending with '%' (e.g. '25%').\n *                  If a string, it must end with '%' to be treated as a percent; otherwise, it is parsed as a number.\n * @param totalValue - The total value to calculate the percent of. Required if `percent` is a percent string.\n * @param defaultValue - The value returned if `percent` is undefined, invalid, or cannot be converted to a number.\n * @param validate - If true, ensures the result does not exceed `totalValue` (when provided).\n * @returns The calculated value, or `defaultValue` for invalid input.\n */\nexport var getPercentValue = function getPercentValue(percent, totalValue) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!isNumber(percent) && typeof percent !== 'string') {\n    return defaultValue;\n  }\n  var value;\n  if (isPercent(percent)) {\n    if (totalValue == null) {\n      return defaultValue;\n    }\n    var index = percent.indexOf('%');\n    value = totalValue * parseFloat(percent.slice(0, index)) / 100;\n  } else {\n    value = +percent;\n  }\n  if (isNan(value)) {\n    value = defaultValue;\n  }\n  if (validate && totalValue != null && value > totalValue) {\n    value = totalValue;\n  }\n  return value;\n};\nexport var hasDuplicate = ary => {\n  if (!Array.isArray(ary)) {\n    return false;\n  }\n  var len = ary.length;\n  var cache = {};\n  for (var i = 0; i < len; i++) {\n    if (!cache[String(ary[i])]) {\n      cache[String(ary[i])] = true;\n    } else {\n      return true;\n    }\n  }\n  return false;\n};\nexport function interpolate(start, end, t) {\n  if (isNumber(start) && isNumber(end)) {\n    return round(start + t * (end - start));\n  }\n  return end;\n}\nexport function findEntryInArray(ary, specifiedKey, specifiedValue) {\n  if (!ary || !ary.length) {\n    return undefined;\n  }\n  return ary.find(entry => entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue);\n}\n/**\n * The least square linear regression\n * @param {Array} data The array of points\n * @returns {Object} The domain of x, and the parameter of linear function\n */\nexport var getLinearRegression = data => {\n  var len = data.length;\n  var xsum = 0;\n  var ysum = 0;\n  var xysum = 0;\n  var xxsum = 0;\n  var xmin = Infinity;\n  var xmax = -Infinity;\n  var xcurrent = 0;\n  var ycurrent = 0;\n  for (var i = 0; i < len; i++) {\n    var _data$i, _data$i2;\n    xcurrent = ((_data$i = data[i]) === null || _data$i === void 0 ? void 0 : _data$i.cx) || 0;\n    ycurrent = ((_data$i2 = data[i]) === null || _data$i2 === void 0 ? void 0 : _data$i2.cy) || 0;\n    xsum += xcurrent;\n    ysum += ycurrent;\n    xysum += xcurrent * ycurrent;\n    xxsum += xcurrent * xcurrent;\n    xmin = Math.min(xmin, xcurrent);\n    xmax = Math.max(xmax, xcurrent);\n  }\n  var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;\n  return {\n    xmin,\n    xmax,\n    a,\n    b: (ysum - a * xsum) / len\n  };\n};\n/**\n * Checks if the value is null or undefined\n * @param value The value to check\n * @returns true if the value is null or undefined\n */\nexport var isNullish = value => {\n  return value === null || typeof value === 'undefined';\n};\n\n/**\n * Uppercase the first letter of a string\n * @param {string} value The string to uppercase\n * @returns {string} The uppercased string\n */\nexport var upperFirst = value => {\n  if (isNullish(value)) {\n    return value;\n  }\n  return \"\".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));\n};\n\n/**\n * Checks if the value is not null nor undefined.\n * @param value The value to check\n * @returns true if the value is not null nor undefined\n */\nexport function isNotNil(value) {\n  return value != null;\n}\n\n/**\n * No-operation function that does nothing.\n * Useful as a placeholder or default callback function.\n */\nexport function noop() {}","map":{"version":3,"names":["get","round","mathSign","value","isNan","isPercent","indexOf","length","isNumber","Number","isNumOrStr","idCounter","uniqueId","prefix","id","concat","getPercentValue","percent","totalValue","defaultValue","arguments","undefined","validate","index","parseFloat","slice","hasDuplicate","ary","Array","isArray","len","cache","i","String","interpolate","start","end","t","findEntryInArray","specifiedKey","specifiedValue","find","entry","getLinearRegression","data","xsum","ysum","xysum","xxsum","xmin","Infinity","xmax","xcurrent","ycurrent","_data$i","_data$i2","cx","cy","Math","min","max","a","b","isNullish","upperFirst","charAt","toUpperCase","isNotNil","noop"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/util/DataUtils.js"],"sourcesContent":["import get from 'es-toolkit/compat/get';\nimport { round } from './round';\nexport var mathSign = value => {\n  if (value === 0) {\n    return 0;\n  }\n  if (value > 0) {\n    return 1;\n  }\n  return -1;\n};\nexport var isNan = value => {\n  // eslint-disable-next-line eqeqeq\n  return typeof value == 'number' && value != +value;\n};\nexport var isPercent = value => typeof value === 'string' && value.indexOf('%') === value.length - 1;\nexport var isNumber = value => (typeof value === 'number' || value instanceof Number) && !isNan(value);\nexport var isNumOrStr = value => isNumber(value) || typeof value === 'string';\nvar idCounter = 0;\nexport var uniqueId = prefix => {\n  var id = ++idCounter;\n  return \"\".concat(prefix || '').concat(id);\n};\n\n/**\n * Calculates the numeric value represented by a percent string or number, based on a total value.\n *\n * - If `percent` is not a number or string, returns `defaultValue`.\n * - If `percent` is a percent string but `totalValue` is null/undefined, returns `defaultValue`.\n * - If the result is NaN, returns `defaultValue`.\n * - If `validate` is true and the result exceeds `totalValue`, returns `totalValue`.\n *\n * @param percent - The percent value to convert. Can be a number (e.g. 25) or a string ending with '%' (e.g. '25%').\n *                  If a string, it must end with '%' to be treated as a percent; otherwise, it is parsed as a number.\n * @param totalValue - The total value to calculate the percent of. Required if `percent` is a percent string.\n * @param defaultValue - The value returned if `percent` is undefined, invalid, or cannot be converted to a number.\n * @param validate - If true, ensures the result does not exceed `totalValue` (when provided).\n * @returns The calculated value, or `defaultValue` for invalid input.\n */\nexport var getPercentValue = function getPercentValue(percent, totalValue) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!isNumber(percent) && typeof percent !== 'string') {\n    return defaultValue;\n  }\n  var value;\n  if (isPercent(percent)) {\n    if (totalValue == null) {\n      return defaultValue;\n    }\n    var index = percent.indexOf('%');\n    value = totalValue * parseFloat(percent.slice(0, index)) / 100;\n  } else {\n    value = +percent;\n  }\n  if (isNan(value)) {\n    value = defaultValue;\n  }\n  if (validate && totalValue != null && value > totalValue) {\n    value = totalValue;\n  }\n  return value;\n};\nexport var hasDuplicate = ary => {\n  if (!Array.isArray(ary)) {\n    return false;\n  }\n  var len = ary.length;\n  var cache = {};\n  for (var i = 0; i < len; i++) {\n    if (!cache[String(ary[i])]) {\n      cache[String(ary[i])] = true;\n    } else {\n      return true;\n    }\n  }\n  return false;\n};\nexport function interpolate(start, end, t) {\n  if (isNumber(start) && isNumber(end)) {\n    return round(start + t * (end - start));\n  }\n  return end;\n}\nexport function findEntryInArray(ary, specifiedKey, specifiedValue) {\n  if (!ary || !ary.length) {\n    return undefined;\n  }\n  return ary.find(entry => entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue);\n}\n/**\n * The least square linear regression\n * @param {Array} data The array of points\n * @returns {Object} The domain of x, and the parameter of linear function\n */\nexport var getLinearRegression = data => {\n  var len = data.length;\n  var xsum = 0;\n  var ysum = 0;\n  var xysum = 0;\n  var xxsum = 0;\n  var xmin = Infinity;\n  var xmax = -Infinity;\n  var xcurrent = 0;\n  var ycurrent = 0;\n  for (var i = 0; i < len; i++) {\n    var _data$i, _data$i2;\n    xcurrent = ((_data$i = data[i]) === null || _data$i === void 0 ? void 0 : _data$i.cx) || 0;\n    ycurrent = ((_data$i2 = data[i]) === null || _data$i2 === void 0 ? void 0 : _data$i2.cy) || 0;\n    xsum += xcurrent;\n    ysum += ycurrent;\n    xysum += xcurrent * ycurrent;\n    xxsum += xcurrent * xcurrent;\n    xmin = Math.min(xmin, xcurrent);\n    xmax = Math.max(xmax, xcurrent);\n  }\n  var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;\n  return {\n    xmin,\n    xmax,\n    a,\n    b: (ysum - a * xsum) / len\n  };\n};\n/**\n * Checks if the value is null or undefined\n * @param value The value to check\n * @returns true if the value is null or undefined\n */\nexport var isNullish = value => {\n  return value === null || typeof value === 'undefined';\n};\n\n/**\n * Uppercase the first letter of a string\n * @param {string} value The string to uppercase\n * @returns {string} The uppercased string\n */\nexport var upperFirst = value => {\n  if (isNullish(value)) {\n    return value;\n  }\n  return \"\".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));\n};\n\n/**\n * Checks if the value is not null nor undefined.\n * @param value The value to check\n * @returns true if the value is not null nor undefined\n */\nexport function isNotNil(value) {\n  return value != null;\n}\n\n/**\n * No-operation function that does nothing.\n * Useful as a placeholder or default callback function.\n */\nexport function noop() {}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}