{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { createSelector } from 'reselect';\nimport range from 'es-toolkit/compat/range';\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { getDomainOfStackGroups, getStackedData, getValueByDataKey, isCategoricalAxis } from '../../util/ChartUtils';\nimport { selectChartDataWithIndexes, selectChartDataWithIndexesIfNotInPanoramaPosition4 } from './dataSelectors';\nimport { isWellFormedNumberDomain, numericalDomainSpecifiedWithoutRequiringData, parseNumericalUserDomain } from '../../util/isDomainSpecifiedByUser';\nimport { getPercentValue, hasDuplicate, isNan, isNotNil, isNumOrStr, mathSign, upperFirst } from '../../util/DataUtils';\nimport { isWellBehavedNumber } from '../../util/isWellBehavedNumber';\nimport { getNiceTickValues, getTickValuesFixedDomain } from '../../util/scale';\nimport { selectChartHeight, selectChartWidth } from './containerSelectors';\nimport { selectAllXAxes, selectAllYAxes } from './selectAllAxes';\nimport { selectChartOffsetInternal } from './selectChartOffsetInternal';\nimport { selectBrushDimensions, selectBrushSettings } from './brushSelectors';\nimport { selectBarCategoryGap, selectChartName, selectReverseStackOrder, selectStackOffsetType } from './rootPropsSelectors';\nimport { selectAngleAxis, selectAngleAxisRange, selectRadiusAxis, selectRadiusAxisRange } from './polarAxisSelectors';\nimport { pickAxisType } from './pickAxisType';\nimport { pickAxisId } from './pickAxisId';\nimport { combineAxisRangeWithReverse } from './combiners/combineAxisRangeWithReverse';\nimport { DEFAULT_Y_AXIS_WIDTH } from '../../util/Constants';\nimport { getStackSeriesIdentifier } from '../../util/stacks/getStackSeriesIdentifier';\nimport { combineDisplayedStackedData } from './combiners/combineDisplayedStackedData';\nimport { isStacked } from '../types/StackedGraphicalItem';\nimport { numberDomainEqualityCheck } from './numberDomainEqualityCheck';\nimport { emptyArraysAreEqualCheck } from './arrayEqualityCheck';\nimport { selectTooltipAxisType } from './selectTooltipAxisType';\nimport { selectTooltipAxisId } from './selectTooltipAxisId';\nimport { rechartsScaleFactory } from '../../util/scale/RechartsScale';\nimport { combineCheckedDomain } from './combiners/combineCheckedDomain';\nexport var defaultNumericDomain = [0, 'auto'];\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitXAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: undefined,\n  height: 30,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'bottom',\n  padding: {\n    left: 0,\n    right: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'category',\n  unit: undefined\n};\nexport var selectXAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.xAxis[axisId];\n};\nexport var selectXAxisSettings = (state, axisId) => {\n  var axis = selectXAxisSettingsNoDefaults(state, axisId);\n  if (axis == null) {\n    return implicitXAxis;\n  }\n  return axis;\n};\n\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitYAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: defaultNumericDomain,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'left',\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'number',\n  unit: undefined,\n  width: DEFAULT_Y_AXIS_WIDTH\n};\nexport var selectYAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.yAxis[axisId];\n};\nexport var selectYAxisSettings = (state, axisId) => {\n  var axis = selectYAxisSettingsNoDefaults(state, axisId);\n  if (axis == null) {\n    return implicitYAxis;\n  }\n  return axis;\n};\nexport var implicitZAxis = {\n  domain: [0, 'auto'],\n  includeHidden: false,\n  reversed: false,\n  allowDataOverflow: false,\n  allowDuplicatedCategory: false,\n  dataKey: undefined,\n  id: 0,\n  name: '',\n  range: [64, 64],\n  scale: 'auto',\n  type: 'number',\n  unit: ''\n};\nexport var selectZAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.zAxis[axisId];\n  if (axis == null) {\n    return implicitZAxis;\n  }\n  return axis;\n};\nexport var selectBaseAxis = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'zAxis':\n      {\n        return selectZAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\nvar selectCartesianAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.\n * @param state Root state\n * @param axisType xAxis | yAxis\n * @param axisId xAxisId | yAxisId\n * @returns axis settings object\n */\nexport var selectRenderableAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * @param state RechartsRootState\n * @return boolean true if there is at least one Bar or RadialBar\n */\nexport var selectHasBar = state => state.graphicalItems.cartesianItems.some(item => item.type === 'bar') || state.graphicalItems.polarItems.some(item => item.type === 'radialBar');\n\n/**\n * Filters CartesianGraphicalItemSettings by the relevant axis ID\n * @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'\n * @param axisId from props, defaults to 0\n *\n * @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis\n */\nexport function itemAxisPredicate(axisType, axisId) {\n  return item => {\n    switch (axisType) {\n      case 'xAxis':\n        // This is sensitive to the data type, as 0 !== '0'. I wonder if we should be more flexible. How does 2.x branch behave? TODO write test for that\n        return 'xAxisId' in item && item.xAxisId === axisId;\n      case 'yAxis':\n        return 'yAxisId' in item && item.yAxisId === axisId;\n      case 'zAxis':\n        return 'zAxisId' in item && item.zAxisId === axisId;\n      case 'angleAxis':\n        return 'angleAxisId' in item && item.angleAxisId === axisId;\n      case 'radiusAxis':\n        return 'radiusAxisId' in item && item.radiusAxisId === axisId;\n      default:\n        return false;\n    }\n  };\n}\n\n// TODO appears there is a bug where this selector is called from polar context, find and fix it.\nexport var selectUnfilteredCartesianItems = state => state.graphicalItems.cartesianItems;\nvar selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);\nexport var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter(item => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {\n    return true;\n  }\n  return !item.hide;\n});\nexport var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], cartesianItems => {\n  return cartesianItems.filter(item => item.type === 'area' || item.type === 'bar').filter(isStacked);\n});\nexport var filterGraphicalNotStackedItems = cartesianItems => cartesianItems.filter(item => !('stackId' in item) || item.stackId === undefined);\nvar selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);\nexport var combineGraphicalItemsData = cartesianItems => cartesianItems.map(item => item.data).filter(Boolean).flat(1);\n\n/**\n * This is a \"cheap\" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.\n * Also does not apply dataKey yet.\n * @param state RechartsRootState\n * @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey\n */\nexport var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var combineDisplayedData = (graphicalItemsData, _ref) => {\n  var {\n    chartData = [],\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (graphicalItemsData.length > 0) {\n    /*\n     * There is no slicing when data is defined on graphical items. Why?\n     * Because Brush ignores data defined on graphical items,\n     * and does not render.\n     * So Brush will never show up in a Scatter chart for example.\n     * This is something we will need to fix.\n     *\n     * Now, when the root chart data is not defined, the dataEndIndex is 0,\n     * which means the itemsData will be sliced to an empty array anyway.\n     * But that's an implementation detail, and we can fix that too.\n     *\n     * Also, in absence of Axis dataKey, we use the dataKey from each item, respectively.\n     * This is the usual pattern for numerical axis, that is the one where bars go up:\n     * users don't specify any dataKey by default and expect the axis to \"just match the data\".\n     */\n    return graphicalItemsData;\n  }\n  return chartData.slice(dataStartIndex, dataEndIndex + 1);\n};\n\n/**\n * This selector will return all data there is in the chart: graphical items, chart root, all together.\n * Useful for figuring out an axis domain (because that needs to know of everything),\n * not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).\n *\n * This function will discard the original indexes, so it is also not useful for anything that depends on ordering.\n */\nexport var selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanoramaPosition4], combineDisplayedData);\nexport var combineAppliedValues = (data, axisSettings, items) => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey)\n    }));\n  }\n  if (items.length > 0) {\n    return items.map(item => item.dataKey).flatMap(dataKey => data.map(entry => ({\n      value: getValueByDataKey(entry, dataKey)\n    })));\n  }\n  return data.map(entry => ({\n    value: entry\n  }));\n};\n\n/**\n * This selector will return all values with the appropriate dataKey applied on them.\n * Which dataKey is appropriate depends on where it is defined.\n *\n * This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.\n */\nexport var selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);\nexport function isErrorBarRelevantForAxisType(axisType, errorBar) {\n  switch (axisType) {\n    case 'xAxis':\n      return errorBar.direction === 'x';\n    case 'yAxis':\n      return errorBar.direction === 'y';\n    default:\n      return false;\n  }\n}\nfunction makeNumber(val) {\n  if (isNumOrStr(val) || val instanceof Date) {\n    var n = Number(val);\n    if (isWellBehavedNumber(n)) {\n      return n;\n    }\n  }\n  return undefined;\n}\nfunction makeDomain(val) {\n  if (Array.isArray(val)) {\n    var attempt = [makeNumber(val[0]), makeNumber(val[1])];\n    if (isWellFormedNumberDomain(attempt)) {\n      return attempt;\n    }\n    return undefined;\n  }\n  var n = makeNumber(val);\n  if (n == null) {\n    return undefined;\n  }\n  return [n, n];\n}\nfunction onlyAllowNumbers(data) {\n  return data.map(makeNumber).filter(isNotNil);\n}\n\n/**\n * @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application\n * @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.\n * @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.\n * @return either undefined or an array of ErrorValue\n */\nexport function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {\n  if (!relevantErrorBars || typeof appliedValue !== 'number' || isNan(appliedValue)) {\n    return [];\n  }\n  if (!relevantErrorBars.length) {\n    return [];\n  }\n  return onlyAllowNumbers(relevantErrorBars.flatMap(eb => {\n    var errorValue = getValueByDataKey(entry, eb.dataKey);\n    var lowBound, highBound;\n    if (Array.isArray(errorValue)) {\n      [lowBound, highBound] = errorValue;\n    } else {\n      lowBound = highBound = errorValue;\n    }\n    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {\n      return undefined;\n    }\n    return [appliedValue - lowBound, appliedValue + highBound];\n  }));\n}\nexport var selectTooltipAxis = state => {\n  var axisType = selectTooltipAxisType(state);\n  var axisId = selectTooltipAxisId(state);\n  return selectRenderableAxisSettings(state, axisType, axisId);\n};\nexport var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], axis => axis === null || axis === void 0 ? void 0 : axis.dataKey);\nexport var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanoramaPosition4, selectTooltipAxis], combineDisplayedStackedData);\nexport var combineStackGroups = (displayedData, items, stackOffsetType, reverseStackOrder) => {\n  var initialItemsGroups = {};\n  var itemsGroup = items.reduce((acc, item) => {\n    if (item.stackId == null) {\n      return acc;\n    }\n    var stack = acc[item.stackId];\n    if (stack == null) {\n      stack = [];\n    }\n    stack.push(item);\n    acc[item.stackId] = stack;\n    return acc;\n  }, initialItemsGroups);\n  return Object.fromEntries(Object.entries(itemsGroup).map(_ref2 => {\n    var [stackId, graphicalItems] = _ref2;\n    var orderedGraphicalItems = reverseStackOrder ? [...graphicalItems].reverse() : graphicalItems;\n    var dataKeys = orderedGraphicalItems.map(getStackSeriesIdentifier);\n    return [stackId, {\n      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that\n      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),\n      graphicalItems: orderedGraphicalItems\n    }];\n  }));\n};\n\n/**\n * Stack groups are groups of graphical items that stack on each other.\n * Stack is a function of axis type (X, Y), axis ID, and stack ID.\n * Graphical items that do not have a stack ID are not going to be present in stack groups.\n */\nexport var selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType, selectReverseStackOrder], combineStackGroups);\nexport var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {\n  var {\n    dataStartIndex,\n    dataEndIndex\n  } = _ref3;\n  if (domainFromUserPreference != null) {\n    // User has specified a domain, so we respect that and we can skip computing anything else\n    return undefined;\n  }\n  if (axisType === 'zAxis') {\n    // ZAxis ignores stacks\n    return undefined;\n  }\n  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);\n  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {\n    return undefined;\n  }\n  return domainOfStackGroups;\n};\nvar selectAllowsDataOverflow = createSelector([selectBaseAxis], axisSettings => axisSettings.allowDataOverflow);\nexport var getDomainDefinition = axisSettings => {\n  var _axisSettings$domain;\n  if (axisSettings == null || !('domain' in axisSettings)) {\n    return defaultNumericDomain;\n  }\n  if (axisSettings.domain != null) {\n    return axisSettings.domain;\n  }\n  if ('ticks' in axisSettings && axisSettings.ticks != null) {\n    if (axisSettings.type === 'number') {\n      var allValues = onlyAllowNumbers(axisSettings.ticks);\n      return [Math.min(...allValues), Math.max(...allValues)];\n    }\n    if (axisSettings.type === 'category') {\n      return axisSettings.ticks.map(String);\n    }\n  }\n  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;\n};\nexport var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);\n\n/**\n * Under certain circumstances, we can determine the domain without looking at the data at all.\n * This is the case when the domain is explicitly specified as numbers, or when it is specified\n * as 'auto' or 'dataMin'/'dataMax' and data overflow is not allowed.\n *\n * In that case, this function will return the domain, otherwise it returns undefined.\n *\n * This is an optimization to avoid unnecessary data processing.\n * @param state\n * @param axisType\n * @param axisId\n * @param isPanorama\n */\nexport var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);\nexport var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType, selectDomainFromUserPreference], combineDomainOfStackGroups, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nexport var selectAllErrorBarSettings = state => state.errorBars;\nvar combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {\n  return cartesianItemsSettings.flatMap(item => {\n    return allErrorBarSettings[item.id];\n  }).filter(Boolean).filter(e => {\n    return isErrorBarRelevantForAxisType(axisType, e);\n  });\n};\nexport var mergeDomains = function mergeDomains() {\n  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {\n    domains[_key] = arguments[_key];\n  }\n  var allDomains = domains.filter(Boolean);\n  if (allDomains.length === 0) {\n    return undefined;\n  }\n  var allValues = allDomains.flat();\n  var min = Math.min(...allValues);\n  var max = Math.max(...allValues);\n  return [min, max];\n};\nexport var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {\n  var lowerEnd, upperEnd;\n  if (items.length > 0) {\n    data.forEach(entry => {\n      items.forEach(item => {\n        var _errorBars$item$id, _axisSettings$dataKey;\n        var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter(errorBar => isErrorBarRelevantForAxisType(axisType, errorBar));\n        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);\n        var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);\n        if (errorDomain.length >= 2) {\n          var localLower = Math.min(...errorDomain);\n          var localUpper = Math.max(...errorDomain);\n          if (lowerEnd == null || localLower < lowerEnd) {\n            lowerEnd = localLower;\n          }\n          if (upperEnd == null || localUpper > upperEnd) {\n            upperEnd = localUpper;\n          }\n        }\n        var dataValueDomain = makeDomain(valueByDataKey);\n        if (dataValueDomain != null) {\n          lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n          upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n        }\n      });\n    });\n  }\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    data.forEach(item => {\n      var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));\n      if (dataValueDomain != null) {\n        lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n        upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n      }\n    });\n  }\n  if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) {\n    return [lowerEnd, upperEnd];\n  }\n  return undefined;\n};\nvar selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nfunction onlyAllowNumbersAndStringsAndDates(item) {\n  var {\n    value\n  } = item;\n  if (isNumOrStr(value) || value instanceof Date) {\n    return value;\n  }\n  return undefined;\n}\nvar computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {\n  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter(v => v != null);\n  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {\n    /*\n     * 1. In an absence of dataKey, Recharts will use array indexes as its categorical domain\n     * 2. When category axis has duplicated text, serial numbers are used to generate scale\n     */\n    return range(0, allDataSquished.length);\n  }\n  if (axisSettings.allowDuplicatedCategory) {\n    return categoricalDomain;\n  }\n  return Array.from(new Set(categoricalDomain));\n};\nexport var selectReferenceDots = state => state.referenceElements.dots;\nexport var filterReferenceElements = (elements, axisType, axisId) => {\n  return elements.filter(el => el.ifOverflow === 'extendDomain').filter(el => {\n    if (axisType === 'xAxis') {\n      return el.xAxisId === axisId;\n    }\n    return el.yAxisId === axisId;\n  });\n};\nexport var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceAreas = state => state.referenceElements.areas;\nexport var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceLines = state => state.referenceElements.lines;\nexport var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);\nexport var combineDotsDomain = (dots, axisType) => {\n  if (dots == null) {\n    return undefined;\n  }\n  var allCoords = onlyAllowNumbers(dots.map(dot => axisType === 'xAxis' ? dot.x : dot.y));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);\nexport var combineAreasDomain = (areas, axisType) => {\n  if (areas == null) {\n    return undefined;\n  }\n  var allCoords = onlyAllowNumbers(areas.flatMap(area => [axisType === 'xAxis' ? area.x1 : area.y1, axisType === 'xAxis' ? area.x2 : area.y2]));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);\nfunction extractXCoordinates(line) {\n  var _line$segment;\n  if (line.x != null) {\n    return onlyAllowNumbers([line.x]);\n  }\n  var segmentCoordinates = (_line$segment = line.segment) === null || _line$segment === void 0 ? void 0 : _line$segment.map(s => s.x);\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n  return onlyAllowNumbers(segmentCoordinates);\n}\nfunction extractYCoordinates(line) {\n  var _line$segment2;\n  if (line.y != null) {\n    return onlyAllowNumbers([line.y]);\n  }\n  var segmentCoordinates = (_line$segment2 = line.segment) === null || _line$segment2 === void 0 ? void 0 : _line$segment2.map(s => s.y);\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n  return onlyAllowNumbers(segmentCoordinates);\n}\nexport var combineLinesDomain = (lines, axisType) => {\n  if (lines == null) {\n    return undefined;\n  }\n  var allCoords = lines.flatMap(line => axisType === 'xAxis' ? extractXCoordinates(line) : extractYCoordinates(line));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceLinesDomain = createSelector([selectReferenceLinesByAxis, pickAxisType], combineLinesDomain);\nvar selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {\n  return mergeDomains(dotsDomain, areasDomain, linesDomain);\n});\nexport var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {\n  if (domainFromUserPreference != null) {\n    // We're done! No need to compute anything else.\n    return domainFromUserPreference;\n  }\n  var shouldIncludeDomainOfStackGroups = layout === 'vertical' && axisType === 'xAxis' || layout === 'horizontal' && axisType === 'yAxis';\n  var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);\n  return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);\n};\nexport var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, selectDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\n\n/**\n * Expand by design maps everything between 0 and 1,\n * there is nothing to compute.\n * See https://d3js.org/d3-shape/stack#stack-offsets\n */\nvar expandDomain = [0, 1];\nexport var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {\n  if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === undefined) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    type\n  } = axisSettings;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && dataKey == null) {\n    var _displayedData$length;\n    return range(0, (_displayedData$length = displayedData === null || displayedData === void 0 ? void 0 : displayedData.length) !== null && _displayedData$length !== void 0 ? _displayedData$length : 0);\n  }\n  if (type === 'category') {\n    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);\n  }\n  if (stackOffsetType === 'expand') {\n    return expandDomain;\n  }\n  return numericalDomain;\n};\nexport var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);\nfunction isSupportedScaleName(name) {\n  return name in d3Scales;\n}\nexport var combineRealScaleType = (axisConfig, hasBar, chartType) => {\n  if (axisConfig == null) {\n    return undefined;\n  }\n  var {\n    scale,\n    type\n  } = axisConfig;\n  if (scale === 'auto') {\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return 'point';\n    }\n    if (type === 'category') {\n      return 'band';\n    }\n    return 'linear';\n  }\n  if (typeof scale === 'string') {\n    var name = \"scale\".concat(upperFirst(scale));\n    return isSupportedScaleName(name) ? name : 'point';\n  }\n  return undefined;\n};\nexport var selectRealScaleType = createSelector([selectBaseAxis, selectHasBar, selectChartName], combineRealScaleType);\nexport function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {\n  if (axisDomain == null || axisRange == null) {\n    return undefined;\n  }\n  if (typeof axis.scale === 'function') {\n    return rechartsScaleFactory(axis.scale, axisDomain, axisRange);\n  }\n  return rechartsScaleFactory(realScaleType, axisDomain, axisRange);\n}\nexport var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {\n  var domainDefinition = getDomainDefinition(axisSettings);\n  if (realScaleType !== 'auto' && realScaleType !== 'linear') {\n    return undefined;\n  }\n  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === 'auto' || domainDefinition[1] === 'auto') && isWellFormedNumberDomain(axisDomain)) {\n    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === 'number' && isWellFormedNumberDomain(axisDomain)) {\n    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  return undefined;\n};\nexport var selectNiceTicks = createSelector([selectAxisDomain, selectRenderableAxisSettings, selectRealScaleType], combineNiceTicks);\nexport var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {\n  if (\n  /*\n   * Angle axis for some reason uses nice ticks when rendering axis tick labels,\n   * but doesn't use nice ticks for extending domain like all the other axes do.\n   * Not really sure why? Is there a good reason,\n   * or is it just because someone added support for nice ticks to the other axes and forgot this one?\n   */\n  axisType !== 'angleAxis' && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === 'number' && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {\n    var _niceTicks$, _niceTicks;\n    var minFromDomain = domain[0];\n    var minFromTicks = (_niceTicks$ = niceTicks[0]) !== null && _niceTicks$ !== void 0 ? _niceTicks$ : 0;\n    var maxFromDomain = domain[1];\n    var maxFromTicks = (_niceTicks = niceTicks[niceTicks.length - 1]) !== null && _niceTicks !== void 0 ? _niceTicks : 0;\n    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];\n  }\n  return domain;\n};\nexport var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);\n\n/**\n * Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).\n * Ignores domain provided by user and only considers domain from data.\n *\n * The result is a number between 0 and 1.\n */\nexport var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {\n  if (!axisSettings || axisSettings.type !== 'number') {\n    return undefined;\n  }\n  var smallestDistanceBetweenValues = Infinity;\n  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map(d => d.value))).sort((a, b) => a - b);\n  var first = sortedValues[0];\n  var last = sortedValues[sortedValues.length - 1];\n  if (first == null || last == null) {\n    return Infinity;\n  }\n  var diff = last - first;\n  if (diff === 0) {\n    return Infinity;\n  }\n  // Only do n - 1 distance calculations because there's only n - 1 distances between n values.\n  for (var i = 0; i < sortedValues.length - 1; i++) {\n    var curr = sortedValues[i];\n    var next = sortedValues[i + 1];\n    if (curr == null || next == null) {\n      continue;\n    }\n    var distance = next - curr;\n    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);\n  }\n  return smallestDistanceBetweenValues / diff;\n});\nvar selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, _4, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {\n  if (!isWellBehavedNumber(smallestDistanceInPercent)) {\n    return 0;\n  }\n  var rangeWidth = layout === 'vertical' ? offset.height : offset.width;\n  if (padding === 'gap') {\n    return smallestDistanceInPercent * rangeWidth / 2;\n  }\n  if (padding === 'no-gap') {\n    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);\n    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n  }\n  return 0;\n});\nexport var selectCalculatedXAxisPadding = (state, axisId, isPanorama) => {\n  var xAxisSettings = selectXAxisSettings(state, axisId);\n  if (xAxisSettings == null || typeof xAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'xAxis', axisId, isPanorama, xAxisSettings.padding);\n};\nexport var selectCalculatedYAxisPadding = (state, axisId, isPanorama) => {\n  var yAxisSettings = selectYAxisSettings(state, axisId);\n  if (yAxisSettings == null || typeof yAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'yAxis', axisId, isPanorama, yAxisSettings.padding);\n};\nvar selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {\n  var _padding$left, _padding$right;\n  if (xAxisSettings == null) {\n    return {\n      left: 0,\n      right: 0\n    };\n  }\n  var {\n    padding\n  } = xAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      left: calculated,\n      right: calculated\n    };\n  }\n  return {\n    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,\n    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated\n  };\n});\nvar selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {\n  var _padding$top, _padding$bottom;\n  if (yAxisSettings == null) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  var {\n    padding\n  } = yAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      top: calculated,\n      bottom: calculated\n    };\n  }\n  return {\n    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,\n    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated\n  };\n});\nexport var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref4;\n  if (isPanorama) {\n    return [brushPadding.left, brushDimensions.width - brushPadding.right];\n  }\n  return [offset.left + padding.left, offset.left + offset.width - padding.right];\n});\nexport var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref5;\n  if (isPanorama) {\n    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];\n  }\n  if (layout === 'horizontal') {\n    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];\n  }\n  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];\n});\nexport var selectAxisRange = (state, axisType, axisId, isPanorama) => {\n  var _selectZAxisSettings;\n  switch (axisType) {\n    case 'xAxis':\n      return combineXAxisRange(state, axisId, isPanorama);\n    case 'yAxis':\n      return combineYAxisRange(state, axisId, isPanorama);\n    case 'zAxis':\n      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;\n    case 'angleAxis':\n      return selectAngleAxisRange(state);\n    case 'radiusAxis':\n      return selectRadiusAxisRange(state, axisId);\n    default:\n      return undefined;\n  }\n};\nexport var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);\nvar selectCheckedAxisDomain = createSelector([selectRealScaleType, selectAxisDomainIncludingNiceTicks], combineCheckedDomain);\nexport var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectCheckedAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectErrorBarsSettings = createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);\nfunction compareIds(a, b) {\n  if (a.id < b.id) {\n    return -1;\n  }\n  if (a.id > b.id) {\n    return 1;\n  }\n  return 0;\n}\nvar pickAxisOrientation = (_state, orientation) => orientation;\nvar pickMirror = (_state, _orientation, mirror) => mirror;\nvar selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar getXAxisSize = (offset, axisSettings) => {\n  return {\n    width: offset.width,\n    height: axisSettings.height\n  };\n};\nvar getYAxisSize = (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n};\nexport var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);\nvar combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {\n  switch (orientation) {\n    case 'top':\n      return offset.top;\n    case 'bottom':\n      return chartHeight - offset.bottom;\n    default:\n      return 0;\n  }\n};\nvar combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {\n  switch (orientation) {\n    case 'left':\n      return offset.left;\n    case 'right':\n      return chartWidth - offset.right;\n    default:\n      return 0;\n  }\n};\nexport var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getXAxisSize(offset, axis);\n    if (position == null) {\n      position = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);\n    }\n    var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.height;\n    position += (needSpace ? -1 : 1) * axisSize.height;\n  });\n  return steps;\n});\nexport var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getYAxisSize(offset, axis);\n    if (position == null) {\n      position = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);\n    }\n    var needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.width;\n    position += (needSpace ? -1 : 1) * axisSize.width;\n  });\n  return steps;\n});\nvar selectXAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectXAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\nexport var selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: offset.left,\n      y: 0\n    };\n  }\n  return {\n    x: offset.left,\n    y: stepOfThisAxis\n  };\n});\nvar selectYAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectYAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\nexport var selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: 0,\n      y: offset.top\n    };\n  }\n  return {\n    x: stepOfThisAxis,\n    y: offset.top\n  };\n});\nexport var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n});\nexport var selectCartesianAxisSize = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSize(state, axisId).width;\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSize(state, axisId).height;\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n};\nexport var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var {\n    allowDuplicatedCategory,\n    type,\n    dataKey\n  } = axis;\n  var isCategorical = isCategoricalAxis(chartLayout, axisType);\n  var allData = appliedValues.map(av => av.value);\n  if (dataKey && isCategorical && type === 'category' && allowDuplicatedCategory && hasDuplicate(allData)) {\n    return allData;\n  }\n  return undefined;\n};\nexport var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);\nexport var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {\n  if (axis == null || axis.dataKey == null) {\n    return undefined;\n  }\n  var {\n    type,\n    scale\n  } = axis;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && (type === 'number' || scale !== 'auto')) {\n    return appliedValues.map(d => d.value);\n  }\n  return undefined;\n};\nexport var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectRenderableAxisSettings, pickAxisType], combineCategoricalDomain);\nexport var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  return {\n    angle: axis.angle,\n    interval: axis.interval,\n    minTickGap: axis.minTickGap,\n    orientation: axis.orientation,\n    tick: axis.tick,\n    tickCount: axis.tickCount,\n    tickFormatter: axis.tickFormatter,\n    ticks: axis.ticks,\n    type: axis.type,\n    unit: axis.unit,\n    axisType,\n    categoricalDomain,\n    duplicateDomain,\n    isCategorical,\n    niceTicks,\n    range: axisRange,\n    realScaleType,\n    scale\n  };\n});\n\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    type,\n    ticks,\n    tickCount\n  } = axis;\n  var offsetForBand =\n  // @ts-expect-error This is testing for `scaleBand` but for band axis the type is reported as `band` so this looks like a dead code with a workaround elsewhere?\n  realScaleType === 'scaleBand' && typeof scale.bandwidth === 'function' ? scale.bandwidth() / 2 : 2;\n  var offset = type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  var ticksOrNiceTicks = ticks || niceTicks;\n  if (ticksOrNiceTicks) {\n    return ticksOrNiceTicks.map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        index,\n        coordinate: scaled + offset,\n        value: entry,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfAxis = createSelector([selectChartLayout, selectRenderableAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);\n\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    tickCount\n  } = axis;\n  var offset = 0;\n  offset = axisType === 'angleAxis' && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use unknown as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectRenderableAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);\n\n/**\n * This is the internal representation of an axis along with its scale function.\n * Here we have already computed the scale function for the axis,\n * and replaced the union type of scale (string | function) with just the function type.\n */\n\nexport var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\nvar selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\n\n/**\n * We are also going to need to implement polar chart directions if we want to support keyboard controls for those.\n */\n\nexport var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {\n  switch (layout) {\n    case 'horizontal':\n      {\n        return allXAxes.some(axis => axis.reversed) ? 'right-to-left' : 'left-to-right';\n      }\n    case 'vertical':\n      {\n        return allYAxes.some(axis => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';\n      }\n    // TODO: make this better. For now, right arrow triggers \"forward\", left arrow \"back\"\n    // however, the tooltip moves an unintuitive direction because of how the indices are rendered\n    case 'centric':\n    case 'radial':\n      {\n        return 'left-to-right';\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n});","map":{"version":3,"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","createSelector","range","d3Scales","selectChartLayout","getDomainOfStackGroups","getStackedData","getValueByDataKey","isCategoricalAxis","selectChartDataWithIndexes","selectChartDataWithIndexesIfNotInPanoramaPosition4","isWellFormedNumberDomain","numericalDomainSpecifiedWithoutRequiringData","parseNumericalUserDomain","getPercentValue","hasDuplicate","isNan","isNotNil","isNumOrStr","mathSign","upperFirst","isWellBehavedNumber","getNiceTickValues","getTickValuesFixedDomain","selectChartHeight","selectChartWidth","selectAllXAxes","selectAllYAxes","selectChartOffsetInternal","selectBrushDimensions","selectBrushSettings","selectBarCategoryGap","selectChartName","selectReverseStackOrder","selectStackOffsetType","selectAngleAxis","selectAngleAxisRange","selectRadiusAxis","selectRadiusAxisRange","pickAxisType","pickAxisId","combineAxisRangeWithReverse","DEFAULT_Y_AXIS_WIDTH","getStackSeriesIdentifier","combineDisplayedStackedData","isStacked","numberDomainEqualityCheck","emptyArraysAreEqualCheck","selectTooltipAxisType","selectTooltipAxisId","rechartsScaleFactory","combineCheckedDomain","defaultNumericDomain","implicitXAxis","allowDataOverflow","allowDecimals","allowDuplicatedCategory","angle","dataKey","undefined","domain","height","hide","id","includeHidden","interval","minTickGap","mirror","name","orientation","padding","left","right","reversed","scale","tick","tickCount","tickFormatter","ticks","type","unit","selectXAxisSettingsNoDefaults","state","axisId","cartesianAxis","xAxis","selectXAxisSettings","axis","implicitYAxis","top","bottom","width","selectYAxisSettingsNoDefaults","yAxis","selectYAxisSettings","implicitZAxis","selectZAxisSettings","zAxis","selectBaseAxis","axisType","Error","concat","selectCartesianAxisSettings","selectRenderableAxisSettings","selectHasBar","graphicalItems","cartesianItems","some","item","polarItems","itemAxisPredicate","xAxisId","yAxisId","zAxisId","angleAxisId","radiusAxisId","selectUnfilteredCartesianItems","selectAxisPredicate","combineGraphicalItemsSettings","axisSettings","axisPredicate","selectCartesianItemsSettings","memoizeOptions","resultEqualityCheck","selectStackedCartesianItemsSettings","filterGraphicalNotStackedItems","stackId","selectCartesianItemsSettingsExceptStacked","combineGraphicalItemsData","map","data","Boolean","flat","selectCartesianGraphicalItemsData","combineDisplayedData","graphicalItemsData","_ref","chartData","dataStartIndex","dataEndIndex","slice","selectDisplayedData","combineAppliedValues","items","flatMap","entry","selectAllAppliedValues","isErrorBarRelevantForAxisType","errorBar","direction","makeNumber","val","Date","n","makeDomain","Array","isArray","attempt","onlyAllowNumbers","getErrorDomainByDataKey","appliedValue","relevantErrorBars","eb","errorValue","lowBound","highBound","selectTooltipAxis","selectTooltipAxisDataKey","selectDisplayedStackedData","combineStackGroups","displayedData","stackOffsetType","reverseStackOrder","initialItemsGroups","itemsGroup","reduce","acc","stack","fromEntries","entries","_ref2","orderedGraphicalItems","reverse","dataKeys","stackedData","selectStackGroups","combineDomainOfStackGroups","stackGroups","_ref3","domainFromUserPreference","domainOfStackGroups","selectAllowsDataOverflow","getDomainDefinition","_axisSettings$domain","allValues","Math","min","max","selectDomainDefinition","selectDomainFromUserPreference","selectDomainOfStackGroups","selectAllErrorBarSettings","errorBars","combineRelevantErrorBarSettings","cartesianItemsSettings","allErrorBarSettings","mergeDomains","_len","domains","_key","allDomains","combineDomainOfAllAppliedNumericalValuesIncludingErrorValues","lowerEnd","upperEnd","_errorBars$item$id","_axisSettings$dataKey","valueByDataKey","errorDomain","localLower","localUpper","dataValueDomain","selectDomainOfAllAppliedNumericalValuesIncludingErrorValues","onlyAllowNumbersAndStringsAndDates","computeDomainOfTypeCategory","allDataSquished","isCategorical","categoricalDomain","v","from","Set","selectReferenceDots","referenceElements","dots","filterReferenceElements","elements","el","ifOverflow","selectReferenceDotsByAxis","selectReferenceAreas","areas","selectReferenceAreasByAxis","selectReferenceLines","lines","selectReferenceLinesByAxis","combineDotsDomain","allCoords","dot","x","y","selectReferenceDotsDomain","combineAreasDomain","area","x1","y1","x2","y2","selectReferenceAreasDomain","extractXCoordinates","line","_line$segment","segmentCoordinates","segment","s","extractYCoordinates","_line$segment2","combineLinesDomain","selectReferenceLinesDomain","selectReferenceElementsDomain","dotsDomain","linesDomain","areasDomain","combineNumericalDomain","domainDefinition","dataAndErrorBarsDomain","referenceElementsDomain","layout","shouldIncludeDomainOfStackGroups","mergedDomains","selectNumericalDomain","expandDomain","combineAxisDomain","allAppliedValues","numericalDomain","_displayedData$length","selectAxisDomain","isSupportedScaleName","combineRealScaleType","axisConfig","hasBar","chartType","indexOf","selectRealScaleType","combineScaleFunction","realScaleType","axisDomain","axisRange","combineNiceTicks","selectNiceTicks","combineAxisDomainWithNiceTicks","niceTicks","_niceTicks$","_niceTicks","minFromDomain","minFromTicks","maxFromDomain","maxFromTicks","selectAxisDomainIncludingNiceTicks","selectSmallestDistanceBetweenValues","smallestDistanceBetweenValues","Infinity","sortedValues","d","sort","a","b","first","last","diff","curr","next","distance","selectCalculatedPadding","_1","_2","_3","_4","smallestDistanceInPercent","barCategoryGap","offset","rangeWidth","gap","halfBand","selectCalculatedXAxisPadding","isPanorama","xAxisSettings","selectCalculatedYAxisPadding","yAxisSettings","selectXAxisPadding","calculated","_padding$left","_padding$right","selectYAxisPadding","_padding$top","_padding$bottom","combineXAxisRange","_state","_axisId","brushDimensions","_ref4","brushPadding","combineYAxisRange","_ref5","selectAxisRange","_selectZAxisSettings","selectAxisRangeWithReverse","selectCheckedAxisDomain","selectAxisScale","selectErrorBarsSettings","compareIds","pickAxisOrientation","pickMirror","_orientation","selectAllXAxesWithOffsetType","allAxes","selectAllYAxesWithOffsetType","getXAxisSize","getYAxisSize","selectXAxisSize","combineXAxisPositionStartingPoint","chartHeight","combineYAxisPositionStartingPoint","chartWidth","selectAllXAxesOffsetSteps","allAxesWithSameOffsetType","steps","position","axisSize","needSpace","selectAllYAxesOffsetSteps","selectXAxisOffsetSteps","selectXAxisPosition","_","allSteps","stepOfThisAxis","selectYAxisOffsetSteps","selectYAxisPosition","selectYAxisSize","selectCartesianAxisSize","combineDuplicateDomain","chartLayout","appliedValues","allData","av","selectDuplicateDomain","combineCategoricalDomain","selectCategoricalDomain","selectAxisPropsNeededForCartesianGridTicksGenerator","duplicateDomain","combineAxisTicks","offsetForBand","bandwidth","ticksOrNiceTicks","index","scaleContent","scaled","coordinate","selectTicksOfAxis","combineGraphicalItemTicks","selectTicksOfGraphicalItem","selectAxisWithScale","selectZAxisScale","selectZAxisWithScale","_axisType","selectChartDirection","allXAxes","allYAxes"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/state/selectors/axisSelectors.js"],"sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { createSelector } from 'reselect';\nimport range from 'es-toolkit/compat/range';\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { getDomainOfStackGroups, getStackedData, getValueByDataKey, isCategoricalAxis } from '../../util/ChartUtils';\nimport { selectChartDataWithIndexes, selectChartDataWithIndexesIfNotInPanoramaPosition4 } from './dataSelectors';\nimport { isWellFormedNumberDomain, numericalDomainSpecifiedWithoutRequiringData, parseNumericalUserDomain } from '../../util/isDomainSpecifiedByUser';\nimport { getPercentValue, hasDuplicate, isNan, isNotNil, isNumOrStr, mathSign, upperFirst } from '../../util/DataUtils';\nimport { isWellBehavedNumber } from '../../util/isWellBehavedNumber';\nimport { getNiceTickValues, getTickValuesFixedDomain } from '../../util/scale';\nimport { selectChartHeight, selectChartWidth } from './containerSelectors';\nimport { selectAllXAxes, selectAllYAxes } from './selectAllAxes';\nimport { selectChartOffsetInternal } from './selectChartOffsetInternal';\nimport { selectBrushDimensions, selectBrushSettings } from './brushSelectors';\nimport { selectBarCategoryGap, selectChartName, selectReverseStackOrder, selectStackOffsetType } from './rootPropsSelectors';\nimport { selectAngleAxis, selectAngleAxisRange, selectRadiusAxis, selectRadiusAxisRange } from './polarAxisSelectors';\nimport { pickAxisType } from './pickAxisType';\nimport { pickAxisId } from './pickAxisId';\nimport { combineAxisRangeWithReverse } from './combiners/combineAxisRangeWithReverse';\nimport { DEFAULT_Y_AXIS_WIDTH } from '../../util/Constants';\nimport { getStackSeriesIdentifier } from '../../util/stacks/getStackSeriesIdentifier';\nimport { combineDisplayedStackedData } from './combiners/combineDisplayedStackedData';\nimport { isStacked } from '../types/StackedGraphicalItem';\nimport { numberDomainEqualityCheck } from './numberDomainEqualityCheck';\nimport { emptyArraysAreEqualCheck } from './arrayEqualityCheck';\nimport { selectTooltipAxisType } from './selectTooltipAxisType';\nimport { selectTooltipAxisId } from './selectTooltipAxisId';\nimport { rechartsScaleFactory } from '../../util/scale/RechartsScale';\nimport { combineCheckedDomain } from './combiners/combineCheckedDomain';\nexport var defaultNumericDomain = [0, 'auto'];\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitXAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: undefined,\n  height: 30,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'bottom',\n  padding: {\n    left: 0,\n    right: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'category',\n  unit: undefined\n};\nexport var selectXAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.xAxis[axisId];\n};\nexport var selectXAxisSettings = (state, axisId) => {\n  var axis = selectXAxisSettingsNoDefaults(state, axisId);\n  if (axis == null) {\n    return implicitXAxis;\n  }\n  return axis;\n};\n\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitYAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: defaultNumericDomain,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'left',\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'number',\n  unit: undefined,\n  width: DEFAULT_Y_AXIS_WIDTH\n};\nexport var selectYAxisSettingsNoDefaults = (state, axisId) => {\n  return state.cartesianAxis.yAxis[axisId];\n};\nexport var selectYAxisSettings = (state, axisId) => {\n  var axis = selectYAxisSettingsNoDefaults(state, axisId);\n  if (axis == null) {\n    return implicitYAxis;\n  }\n  return axis;\n};\nexport var implicitZAxis = {\n  domain: [0, 'auto'],\n  includeHidden: false,\n  reversed: false,\n  allowDataOverflow: false,\n  allowDuplicatedCategory: false,\n  dataKey: undefined,\n  id: 0,\n  name: '',\n  range: [64, 64],\n  scale: 'auto',\n  type: 'number',\n  unit: ''\n};\nexport var selectZAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.zAxis[axisId];\n  if (axis == null) {\n    return implicitZAxis;\n  }\n  return axis;\n};\nexport var selectBaseAxis = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'zAxis':\n      {\n        return selectZAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\nvar selectCartesianAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.\n * @param state Root state\n * @param axisType xAxis | yAxis\n * @param axisId xAxisId | yAxisId\n * @returns axis settings object\n */\nexport var selectRenderableAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * @param state RechartsRootState\n * @return boolean true if there is at least one Bar or RadialBar\n */\nexport var selectHasBar = state => state.graphicalItems.cartesianItems.some(item => item.type === 'bar') || state.graphicalItems.polarItems.some(item => item.type === 'radialBar');\n\n/**\n * Filters CartesianGraphicalItemSettings by the relevant axis ID\n * @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'\n * @param axisId from props, defaults to 0\n *\n * @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis\n */\nexport function itemAxisPredicate(axisType, axisId) {\n  return item => {\n    switch (axisType) {\n      case 'xAxis':\n        // This is sensitive to the data type, as 0 !== '0'. I wonder if we should be more flexible. How does 2.x branch behave? TODO write test for that\n        return 'xAxisId' in item && item.xAxisId === axisId;\n      case 'yAxis':\n        return 'yAxisId' in item && item.yAxisId === axisId;\n      case 'zAxis':\n        return 'zAxisId' in item && item.zAxisId === axisId;\n      case 'angleAxis':\n        return 'angleAxisId' in item && item.angleAxisId === axisId;\n      case 'radiusAxis':\n        return 'radiusAxisId' in item && item.radiusAxisId === axisId;\n      default:\n        return false;\n    }\n  };\n}\n\n// TODO appears there is a bug where this selector is called from polar context, find and fix it.\nexport var selectUnfilteredCartesianItems = state => state.graphicalItems.cartesianItems;\nvar selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);\nexport var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter(item => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {\n    return true;\n  }\n  return !item.hide;\n});\nexport var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], cartesianItems => {\n  return cartesianItems.filter(item => item.type === 'area' || item.type === 'bar').filter(isStacked);\n});\nexport var filterGraphicalNotStackedItems = cartesianItems => cartesianItems.filter(item => !('stackId' in item) || item.stackId === undefined);\nvar selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);\nexport var combineGraphicalItemsData = cartesianItems => cartesianItems.map(item => item.data).filter(Boolean).flat(1);\n\n/**\n * This is a \"cheap\" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.\n * Also does not apply dataKey yet.\n * @param state RechartsRootState\n * @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey\n */\nexport var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, {\n  memoizeOptions: {\n    resultEqualityCheck: emptyArraysAreEqualCheck\n  }\n});\nexport var combineDisplayedData = (graphicalItemsData, _ref) => {\n  var {\n    chartData = [],\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (graphicalItemsData.length > 0) {\n    /*\n     * There is no slicing when data is defined on graphical items. Why?\n     * Because Brush ignores data defined on graphical items,\n     * and does not render.\n     * So Brush will never show up in a Scatter chart for example.\n     * This is something we will need to fix.\n     *\n     * Now, when the root chart data is not defined, the dataEndIndex is 0,\n     * which means the itemsData will be sliced to an empty array anyway.\n     * But that's an implementation detail, and we can fix that too.\n     *\n     * Also, in absence of Axis dataKey, we use the dataKey from each item, respectively.\n     * This is the usual pattern for numerical axis, that is the one where bars go up:\n     * users don't specify any dataKey by default and expect the axis to \"just match the data\".\n     */\n    return graphicalItemsData;\n  }\n  return chartData.slice(dataStartIndex, dataEndIndex + 1);\n};\n\n/**\n * This selector will return all data there is in the chart: graphical items, chart root, all together.\n * Useful for figuring out an axis domain (because that needs to know of everything),\n * not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).\n *\n * This function will discard the original indexes, so it is also not useful for anything that depends on ordering.\n */\nexport var selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanoramaPosition4], combineDisplayedData);\nexport var combineAppliedValues = (data, axisSettings, items) => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey)\n    }));\n  }\n  if (items.length > 0) {\n    return items.map(item => item.dataKey).flatMap(dataKey => data.map(entry => ({\n      value: getValueByDataKey(entry, dataKey)\n    })));\n  }\n  return data.map(entry => ({\n    value: entry\n  }));\n};\n\n/**\n * This selector will return all values with the appropriate dataKey applied on them.\n * Which dataKey is appropriate depends on where it is defined.\n *\n * This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.\n */\nexport var selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);\nexport function isErrorBarRelevantForAxisType(axisType, errorBar) {\n  switch (axisType) {\n    case 'xAxis':\n      return errorBar.direction === 'x';\n    case 'yAxis':\n      return errorBar.direction === 'y';\n    default:\n      return false;\n  }\n}\nfunction makeNumber(val) {\n  if (isNumOrStr(val) || val instanceof Date) {\n    var n = Number(val);\n    if (isWellBehavedNumber(n)) {\n      return n;\n    }\n  }\n  return undefined;\n}\nfunction makeDomain(val) {\n  if (Array.isArray(val)) {\n    var attempt = [makeNumber(val[0]), makeNumber(val[1])];\n    if (isWellFormedNumberDomain(attempt)) {\n      return attempt;\n    }\n    return undefined;\n  }\n  var n = makeNumber(val);\n  if (n == null) {\n    return undefined;\n  }\n  return [n, n];\n}\nfunction onlyAllowNumbers(data) {\n  return data.map(makeNumber).filter(isNotNil);\n}\n\n/**\n * @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application\n * @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.\n * @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.\n * @return either undefined or an array of ErrorValue\n */\nexport function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {\n  if (!relevantErrorBars || typeof appliedValue !== 'number' || isNan(appliedValue)) {\n    return [];\n  }\n  if (!relevantErrorBars.length) {\n    return [];\n  }\n  return onlyAllowNumbers(relevantErrorBars.flatMap(eb => {\n    var errorValue = getValueByDataKey(entry, eb.dataKey);\n    var lowBound, highBound;\n    if (Array.isArray(errorValue)) {\n      [lowBound, highBound] = errorValue;\n    } else {\n      lowBound = highBound = errorValue;\n    }\n    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {\n      return undefined;\n    }\n    return [appliedValue - lowBound, appliedValue + highBound];\n  }));\n}\nexport var selectTooltipAxis = state => {\n  var axisType = selectTooltipAxisType(state);\n  var axisId = selectTooltipAxisId(state);\n  return selectRenderableAxisSettings(state, axisType, axisId);\n};\nexport var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], axis => axis === null || axis === void 0 ? void 0 : axis.dataKey);\nexport var selectDisplayedStackedData = createSelector([selectStackedCartesianItemsSettings, selectChartDataWithIndexesIfNotInPanoramaPosition4, selectTooltipAxis], combineDisplayedStackedData);\nexport var combineStackGroups = (displayedData, items, stackOffsetType, reverseStackOrder) => {\n  var initialItemsGroups = {};\n  var itemsGroup = items.reduce((acc, item) => {\n    if (item.stackId == null) {\n      return acc;\n    }\n    var stack = acc[item.stackId];\n    if (stack == null) {\n      stack = [];\n    }\n    stack.push(item);\n    acc[item.stackId] = stack;\n    return acc;\n  }, initialItemsGroups);\n  return Object.fromEntries(Object.entries(itemsGroup).map(_ref2 => {\n    var [stackId, graphicalItems] = _ref2;\n    var orderedGraphicalItems = reverseStackOrder ? [...graphicalItems].reverse() : graphicalItems;\n    var dataKeys = orderedGraphicalItems.map(getStackSeriesIdentifier);\n    return [stackId, {\n      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that\n      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),\n      graphicalItems: orderedGraphicalItems\n    }];\n  }));\n};\n\n/**\n * Stack groups are groups of graphical items that stack on each other.\n * Stack is a function of axis type (X, Y), axis ID, and stack ID.\n * Graphical items that do not have a stack ID are not going to be present in stack groups.\n */\nexport var selectStackGroups = createSelector([selectDisplayedStackedData, selectStackedCartesianItemsSettings, selectStackOffsetType, selectReverseStackOrder], combineStackGroups);\nexport var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {\n  var {\n    dataStartIndex,\n    dataEndIndex\n  } = _ref3;\n  if (domainFromUserPreference != null) {\n    // User has specified a domain, so we respect that and we can skip computing anything else\n    return undefined;\n  }\n  if (axisType === 'zAxis') {\n    // ZAxis ignores stacks\n    return undefined;\n  }\n  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);\n  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {\n    return undefined;\n  }\n  return domainOfStackGroups;\n};\nvar selectAllowsDataOverflow = createSelector([selectBaseAxis], axisSettings => axisSettings.allowDataOverflow);\nexport var getDomainDefinition = axisSettings => {\n  var _axisSettings$domain;\n  if (axisSettings == null || !('domain' in axisSettings)) {\n    return defaultNumericDomain;\n  }\n  if (axisSettings.domain != null) {\n    return axisSettings.domain;\n  }\n  if ('ticks' in axisSettings && axisSettings.ticks != null) {\n    if (axisSettings.type === 'number') {\n      var allValues = onlyAllowNumbers(axisSettings.ticks);\n      return [Math.min(...allValues), Math.max(...allValues)];\n    }\n    if (axisSettings.type === 'category') {\n      return axisSettings.ticks.map(String);\n    }\n  }\n  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;\n};\nexport var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);\n\n/**\n * Under certain circumstances, we can determine the domain without looking at the data at all.\n * This is the case when the domain is explicitly specified as numbers, or when it is specified\n * as 'auto' or 'dataMin'/'dataMax' and data overflow is not allowed.\n *\n * In that case, this function will return the domain, otherwise it returns undefined.\n *\n * This is an optimization to avoid unnecessary data processing.\n * @param state\n * @param axisType\n * @param axisId\n * @param isPanorama\n */\nexport var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);\nexport var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType, selectDomainFromUserPreference], combineDomainOfStackGroups, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nexport var selectAllErrorBarSettings = state => state.errorBars;\nvar combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {\n  return cartesianItemsSettings.flatMap(item => {\n    return allErrorBarSettings[item.id];\n  }).filter(Boolean).filter(e => {\n    return isErrorBarRelevantForAxisType(axisType, e);\n  });\n};\nexport var mergeDomains = function mergeDomains() {\n  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {\n    domains[_key] = arguments[_key];\n  }\n  var allDomains = domains.filter(Boolean);\n  if (allDomains.length === 0) {\n    return undefined;\n  }\n  var allValues = allDomains.flat();\n  var min = Math.min(...allValues);\n  var max = Math.max(...allValues);\n  return [min, max];\n};\nexport var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {\n  var lowerEnd, upperEnd;\n  if (items.length > 0) {\n    data.forEach(entry => {\n      items.forEach(item => {\n        var _errorBars$item$id, _axisSettings$dataKey;\n        var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter(errorBar => isErrorBarRelevantForAxisType(axisType, errorBar));\n        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);\n        var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);\n        if (errorDomain.length >= 2) {\n          var localLower = Math.min(...errorDomain);\n          var localUpper = Math.max(...errorDomain);\n          if (lowerEnd == null || localLower < lowerEnd) {\n            lowerEnd = localLower;\n          }\n          if (upperEnd == null || localUpper > upperEnd) {\n            upperEnd = localUpper;\n          }\n        }\n        var dataValueDomain = makeDomain(valueByDataKey);\n        if (dataValueDomain != null) {\n          lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n          upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n        }\n      });\n    });\n  }\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    data.forEach(item => {\n      var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));\n      if (dataValueDomain != null) {\n        lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);\n        upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);\n      }\n    });\n  }\n  if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) {\n    return [lowerEnd, upperEnd];\n  }\n  return undefined;\n};\nvar selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, selectAllErrorBarSettings, pickAxisType], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\nfunction onlyAllowNumbersAndStringsAndDates(item) {\n  var {\n    value\n  } = item;\n  if (isNumOrStr(value) || value instanceof Date) {\n    return value;\n  }\n  return undefined;\n}\nvar computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {\n  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter(v => v != null);\n  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {\n    /*\n     * 1. In an absence of dataKey, Recharts will use array indexes as its categorical domain\n     * 2. When category axis has duplicated text, serial numbers are used to generate scale\n     */\n    return range(0, allDataSquished.length);\n  }\n  if (axisSettings.allowDuplicatedCategory) {\n    return categoricalDomain;\n  }\n  return Array.from(new Set(categoricalDomain));\n};\nexport var selectReferenceDots = state => state.referenceElements.dots;\nexport var filterReferenceElements = (elements, axisType, axisId) => {\n  return elements.filter(el => el.ifOverflow === 'extendDomain').filter(el => {\n    if (axisType === 'xAxis') {\n      return el.xAxisId === axisId;\n    }\n    return el.yAxisId === axisId;\n  });\n};\nexport var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceAreas = state => state.referenceElements.areas;\nexport var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceLines = state => state.referenceElements.lines;\nexport var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);\nexport var combineDotsDomain = (dots, axisType) => {\n  if (dots == null) {\n    return undefined;\n  }\n  var allCoords = onlyAllowNumbers(dots.map(dot => axisType === 'xAxis' ? dot.x : dot.y));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);\nexport var combineAreasDomain = (areas, axisType) => {\n  if (areas == null) {\n    return undefined;\n  }\n  var allCoords = onlyAllowNumbers(areas.flatMap(area => [axisType === 'xAxis' ? area.x1 : area.y1, axisType === 'xAxis' ? area.x2 : area.y2]));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);\nfunction extractXCoordinates(line) {\n  var _line$segment;\n  if (line.x != null) {\n    return onlyAllowNumbers([line.x]);\n  }\n  var segmentCoordinates = (_line$segment = line.segment) === null || _line$segment === void 0 ? void 0 : _line$segment.map(s => s.x);\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n  return onlyAllowNumbers(segmentCoordinates);\n}\nfunction extractYCoordinates(line) {\n  var _line$segment2;\n  if (line.y != null) {\n    return onlyAllowNumbers([line.y]);\n  }\n  var segmentCoordinates = (_line$segment2 = line.segment) === null || _line$segment2 === void 0 ? void 0 : _line$segment2.map(s => s.y);\n  if (segmentCoordinates == null || segmentCoordinates.length === 0) {\n    return [];\n  }\n  return onlyAllowNumbers(segmentCoordinates);\n}\nexport var combineLinesDomain = (lines, axisType) => {\n  if (lines == null) {\n    return undefined;\n  }\n  var allCoords = lines.flatMap(line => axisType === 'xAxis' ? extractXCoordinates(line) : extractYCoordinates(line));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceLinesDomain = createSelector([selectReferenceLinesByAxis, pickAxisType], combineLinesDomain);\nvar selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {\n  return mergeDomains(dotsDomain, areasDomain, linesDomain);\n});\nexport var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {\n  if (domainFromUserPreference != null) {\n    // We're done! No need to compute anything else.\n    return domainFromUserPreference;\n  }\n  var shouldIncludeDomainOfStackGroups = layout === 'vertical' && axisType === 'xAxis' || layout === 'horizontal' && axisType === 'yAxis';\n  var mergedDomains = shouldIncludeDomainOfStackGroups ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);\n  return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);\n};\nexport var selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainFromUserPreference, selectDomainOfStackGroups, selectDomainOfAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain, selectChartLayout, pickAxisType], combineNumericalDomain, {\n  memoizeOptions: {\n    resultEqualityCheck: numberDomainEqualityCheck\n  }\n});\n\n/**\n * Expand by design maps everything between 0 and 1,\n * there is nothing to compute.\n * See https://d3js.org/d3-shape/stack#stack-offsets\n */\nvar expandDomain = [0, 1];\nexport var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {\n  if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === undefined) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    type\n  } = axisSettings;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && dataKey == null) {\n    var _displayedData$length;\n    return range(0, (_displayedData$length = displayedData === null || displayedData === void 0 ? void 0 : displayedData.length) !== null && _displayedData$length !== void 0 ? _displayedData$length : 0);\n  }\n  if (type === 'category') {\n    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);\n  }\n  if (stackOffsetType === 'expand') {\n    return expandDomain;\n  }\n  return numericalDomain;\n};\nexport var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);\nfunction isSupportedScaleName(name) {\n  return name in d3Scales;\n}\nexport var combineRealScaleType = (axisConfig, hasBar, chartType) => {\n  if (axisConfig == null) {\n    return undefined;\n  }\n  var {\n    scale,\n    type\n  } = axisConfig;\n  if (scale === 'auto') {\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return 'point';\n    }\n    if (type === 'category') {\n      return 'band';\n    }\n    return 'linear';\n  }\n  if (typeof scale === 'string') {\n    var name = \"scale\".concat(upperFirst(scale));\n    return isSupportedScaleName(name) ? name : 'point';\n  }\n  return undefined;\n};\nexport var selectRealScaleType = createSelector([selectBaseAxis, selectHasBar, selectChartName], combineRealScaleType);\nexport function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {\n  if (axisDomain == null || axisRange == null) {\n    return undefined;\n  }\n  if (typeof axis.scale === 'function') {\n    return rechartsScaleFactory(axis.scale, axisDomain, axisRange);\n  }\n  return rechartsScaleFactory(realScaleType, axisDomain, axisRange);\n}\nexport var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {\n  var domainDefinition = getDomainDefinition(axisSettings);\n  if (realScaleType !== 'auto' && realScaleType !== 'linear') {\n    return undefined;\n  }\n  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === 'auto' || domainDefinition[1] === 'auto') && isWellFormedNumberDomain(axisDomain)) {\n    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === 'number' && isWellFormedNumberDomain(axisDomain)) {\n    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  return undefined;\n};\nexport var selectNiceTicks = createSelector([selectAxisDomain, selectRenderableAxisSettings, selectRealScaleType], combineNiceTicks);\nexport var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {\n  if (\n  /*\n   * Angle axis for some reason uses nice ticks when rendering axis tick labels,\n   * but doesn't use nice ticks for extending domain like all the other axes do.\n   * Not really sure why? Is there a good reason,\n   * or is it just because someone added support for nice ticks to the other axes and forgot this one?\n   */\n  axisType !== 'angleAxis' && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === 'number' && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {\n    var _niceTicks$, _niceTicks;\n    var minFromDomain = domain[0];\n    var minFromTicks = (_niceTicks$ = niceTicks[0]) !== null && _niceTicks$ !== void 0 ? _niceTicks$ : 0;\n    var maxFromDomain = domain[1];\n    var maxFromTicks = (_niceTicks = niceTicks[niceTicks.length - 1]) !== null && _niceTicks !== void 0 ? _niceTicks : 0;\n    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];\n  }\n  return domain;\n};\nexport var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);\n\n/**\n * Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).\n * Ignores domain provided by user and only considers domain from data.\n *\n * The result is a number between 0 and 1.\n */\nexport var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {\n  if (!axisSettings || axisSettings.type !== 'number') {\n    return undefined;\n  }\n  var smallestDistanceBetweenValues = Infinity;\n  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map(d => d.value))).sort((a, b) => a - b);\n  var first = sortedValues[0];\n  var last = sortedValues[sortedValues.length - 1];\n  if (first == null || last == null) {\n    return Infinity;\n  }\n  var diff = last - first;\n  if (diff === 0) {\n    return Infinity;\n  }\n  // Only do n - 1 distance calculations because there's only n - 1 distances between n values.\n  for (var i = 0; i < sortedValues.length - 1; i++) {\n    var curr = sortedValues[i];\n    var next = sortedValues[i + 1];\n    if (curr == null || next == null) {\n      continue;\n    }\n    var distance = next - curr;\n    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);\n  }\n  return smallestDistanceBetweenValues / diff;\n});\nvar selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, _4, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {\n  if (!isWellBehavedNumber(smallestDistanceInPercent)) {\n    return 0;\n  }\n  var rangeWidth = layout === 'vertical' ? offset.height : offset.width;\n  if (padding === 'gap') {\n    return smallestDistanceInPercent * rangeWidth / 2;\n  }\n  if (padding === 'no-gap') {\n    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);\n    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n  }\n  return 0;\n});\nexport var selectCalculatedXAxisPadding = (state, axisId, isPanorama) => {\n  var xAxisSettings = selectXAxisSettings(state, axisId);\n  if (xAxisSettings == null || typeof xAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'xAxis', axisId, isPanorama, xAxisSettings.padding);\n};\nexport var selectCalculatedYAxisPadding = (state, axisId, isPanorama) => {\n  var yAxisSettings = selectYAxisSettings(state, axisId);\n  if (yAxisSettings == null || typeof yAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'yAxis', axisId, isPanorama, yAxisSettings.padding);\n};\nvar selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {\n  var _padding$left, _padding$right;\n  if (xAxisSettings == null) {\n    return {\n      left: 0,\n      right: 0\n    };\n  }\n  var {\n    padding\n  } = xAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      left: calculated,\n      right: calculated\n    };\n  }\n  return {\n    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,\n    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated\n  };\n});\nvar selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {\n  var _padding$top, _padding$bottom;\n  if (yAxisSettings == null) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  var {\n    padding\n  } = yAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      top: calculated,\n      bottom: calculated\n    };\n  }\n  return {\n    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,\n    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated\n  };\n});\nexport var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref4;\n  if (isPanorama) {\n    return [brushPadding.left, brushDimensions.width - brushPadding.right];\n  }\n  return [offset.left + padding.left, offset.left + offset.width - padding.right];\n});\nexport var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref5;\n  if (isPanorama) {\n    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];\n  }\n  if (layout === 'horizontal') {\n    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];\n  }\n  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];\n});\nexport var selectAxisRange = (state, axisType, axisId, isPanorama) => {\n  var _selectZAxisSettings;\n  switch (axisType) {\n    case 'xAxis':\n      return combineXAxisRange(state, axisId, isPanorama);\n    case 'yAxis':\n      return combineYAxisRange(state, axisId, isPanorama);\n    case 'zAxis':\n      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;\n    case 'angleAxis':\n      return selectAngleAxisRange(state);\n    case 'radiusAxis':\n      return selectRadiusAxisRange(state, axisId);\n    default:\n      return undefined;\n  }\n};\nexport var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);\nvar selectCheckedAxisDomain = createSelector([selectRealScaleType, selectAxisDomainIncludingNiceTicks], combineCheckedDomain);\nexport var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectCheckedAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectErrorBarsSettings = createSelector([selectCartesianItemsSettings, selectAllErrorBarSettings, pickAxisType], combineRelevantErrorBarSettings);\nfunction compareIds(a, b) {\n  if (a.id < b.id) {\n    return -1;\n  }\n  if (a.id > b.id) {\n    return 1;\n  }\n  return 0;\n}\nvar pickAxisOrientation = (_state, orientation) => orientation;\nvar pickMirror = (_state, _orientation, mirror) => mirror;\nvar selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar getXAxisSize = (offset, axisSettings) => {\n  return {\n    width: offset.width,\n    height: axisSettings.height\n  };\n};\nvar getYAxisSize = (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n};\nexport var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);\nvar combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {\n  switch (orientation) {\n    case 'top':\n      return offset.top;\n    case 'bottom':\n      return chartHeight - offset.bottom;\n    default:\n      return 0;\n  }\n};\nvar combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {\n  switch (orientation) {\n    case 'left':\n      return offset.left;\n    case 'right':\n      return chartWidth - offset.right;\n    default:\n      return 0;\n  }\n};\nexport var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getXAxisSize(offset, axis);\n    if (position == null) {\n      position = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);\n    }\n    var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.height;\n    position += (needSpace ? -1 : 1) * axisSize.height;\n  });\n  return steps;\n});\nexport var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getYAxisSize(offset, axis);\n    if (position == null) {\n      position = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);\n    }\n    var needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.width;\n    position += (needSpace ? -1 : 1) * axisSize.width;\n  });\n  return steps;\n});\nvar selectXAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectXAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\nexport var selectXAxisPosition = createSelector([selectChartOffsetInternal, selectXAxisSettings, selectXAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: offset.left,\n      y: 0\n    };\n  }\n  return {\n    x: offset.left,\n    y: stepOfThisAxis\n  };\n});\nvar selectYAxisOffsetSteps = (state, axisId) => {\n  var axisSettings = selectYAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n};\nexport var selectYAxisPosition = createSelector([selectChartOffsetInternal, selectYAxisSettings, selectYAxisOffsetSteps, (_, axisId) => axisId], (offset, axisSettings, allSteps, axisId) => {\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: 0,\n      y: offset.top\n    };\n  }\n  return {\n    x: stepOfThisAxis,\n    y: offset.top\n  };\n});\nexport var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n});\nexport var selectCartesianAxisSize = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSize(state, axisId).width;\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSize(state, axisId).height;\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n};\nexport var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var {\n    allowDuplicatedCategory,\n    type,\n    dataKey\n  } = axis;\n  var isCategorical = isCategoricalAxis(chartLayout, axisType);\n  var allData = appliedValues.map(av => av.value);\n  if (dataKey && isCategorical && type === 'category' && allowDuplicatedCategory && hasDuplicate(allData)) {\n    return allData;\n  }\n  return undefined;\n};\nexport var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);\nexport var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {\n  if (axis == null || axis.dataKey == null) {\n    return undefined;\n  }\n  var {\n    type,\n    scale\n  } = axis;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && (type === 'number' || scale !== 'auto')) {\n    return appliedValues.map(d => d.value);\n  }\n  return undefined;\n};\nexport var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectRenderableAxisSettings, pickAxisType], combineCategoricalDomain);\nexport var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  return {\n    angle: axis.angle,\n    interval: axis.interval,\n    minTickGap: axis.minTickGap,\n    orientation: axis.orientation,\n    tick: axis.tick,\n    tickCount: axis.tickCount,\n    tickFormatter: axis.tickFormatter,\n    ticks: axis.ticks,\n    type: axis.type,\n    unit: axis.unit,\n    axisType,\n    categoricalDomain,\n    duplicateDomain,\n    isCategorical,\n    niceTicks,\n    range: axisRange,\n    realScaleType,\n    scale\n  };\n});\n\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    type,\n    ticks,\n    tickCount\n  } = axis;\n  var offsetForBand =\n  // @ts-expect-error This is testing for `scaleBand` but for band axis the type is reported as `band` so this looks like a dead code with a workaround elsewhere?\n  realScaleType === 'scaleBand' && typeof scale.bandwidth === 'function' ? scale.bandwidth() / 2 : 2;\n  var offset = type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  var ticksOrNiceTicks = ticks || niceTicks;\n  if (ticksOrNiceTicks) {\n    return ticksOrNiceTicks.map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        index,\n        coordinate: scaled + offset,\n        value: entry,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfAxis = createSelector([selectChartLayout, selectRenderableAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);\n\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    tickCount\n  } = axis;\n  var offset = 0;\n  offset = axisType === 'angleAxis' && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use unknown as index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\nexport var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectRenderableAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);\n\n/**\n * This is the internal representation of an axis along with its scale function.\n * Here we have already computed the scale function for the axis,\n * and replaced the union type of scale (string | function) with just the function type.\n */\n\nexport var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\nvar selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\n\n/**\n * We are also going to need to implement polar chart directions if we want to support keyboard controls for those.\n */\n\nexport var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {\n  switch (layout) {\n    case 'horizontal':\n      {\n        return allXAxes.some(axis => axis.reversed) ? 'right-to-left' : 'left-to-right';\n      }\n    case 'vertical':\n      {\n        return allYAxes.some(axis => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';\n      }\n    // TODO: make this better. For now, right arrow triggers \"forward\", left arrow \"back\"\n    // however, the tooltip moves an unintuitive direction because of how the indices are rendered\n    case 'centric':\n    case 'radial':\n      {\n        return 'left-to-right';\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}