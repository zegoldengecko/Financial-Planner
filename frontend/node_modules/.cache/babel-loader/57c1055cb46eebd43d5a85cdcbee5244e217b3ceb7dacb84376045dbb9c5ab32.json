{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNotNil, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scaled + offset,\n        value: entry,\n        offset,\n        index\n      };\n    }).filter(isNotNil);\n    return result;\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as an index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var _series$;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var series1 = col[1];\n      var series0 = col[0];\n      var value = isNan(series1) ? series0 : series1;\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = negative;\n        negative += value;\n        col[1] = negative;\n      }\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var _series$2;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$2 = series[0]) === null || _series$2 === void 0 ? void 0 : _series$2.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var value = isNan(col[1]) ? col[0] : col[1];\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = 0;\n        col[1] = 0;\n      }\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var _STACK_OFFSET_MAP$off;\n  var offsetAccessor = (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) !== null && _STACK_OFFSET_MAP$off !== void 0 ? _STACK_OFFSET_MAP$off : stackOffsetNone;\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  var result = stack(data);\n\n  // Post-process ranged data: if value is an array of two numbers, use them directly without stacking\n  result.forEach((series, seriesIndex) => {\n    series.forEach((point, pointIndex) => {\n      var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);\n      if (Array.isArray(value) && value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[0] = value[0];\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[1] = value[1];\n      }\n    });\n  });\n  return result;\n};\n\n/**\n * Externally, we accept both strings and numbers as stack IDs\n * @inline\n */\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks !== null && ticks !== void 0 && ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n  var scaled = axis.scale.map(value);\n  if (!isNumber(scaled)) {\n    return null;\n  }\n  return scaled;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  if (isNullish(value)) {\n    return null;\n  }\n  var scaled = axis.scale.map(value);\n  if (!isNumber(scaled)) {\n    return null;\n  }\n  return scaled - bandSize / 2 + offset;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    if (!group) {\n      return result;\n    }\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      if (!isWellBehavedNumber(s[0]) || !isWellBehavedNumber(s[1])) {\n        return res;\n      }\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min(((cur === null || cur === void 0 ? void 0 : cur.coordinate) || 0) - ((prev === null || prev === void 0 ? void 0 : prev.coordinate) || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};","map":{"version":3,"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","sortBy","get","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","findEntryInArray","isNan","isNotNil","isNullish","isNumber","isNumOrStr","mathSign","getSliced","isWellBehavedNumber","getValueByDataKey","obj","dataKey","defaultValue","appendOffsetOfLegend","offset","legendSettings","legendSize","width","boxWidth","height","boxHeight","align","verticalAlign","layout","isCategoricalAxis","axisType","getCoordinatesOfGrid","ticks","minValue","maxValue","syncWithTicks","map","entry","coordinate","hasMin","hasMax","values","getTicksOfAxis","axis","isGrid","isAll","duplicateDomain","type","range","scale","realScaleType","isCategorical","categoricalDomain","tickCount","niceTicks","offsetForBand","bandwidth","result","index","scaleContent","indexOf","scaled","domain","truncateByDomain","Math","min","max","offsetSign","series","_series$","n","m","j","positive","negative","row","col","series1","series0","offsetPositive","_series$2","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","data","dataKeys","offsetType","_STACK_OFFSET_MAP$off","offsetAccessor","d","key","order","seriesIndex","point","pointIndex","Array","isArray","getNormalizedStackId","publicStackId","undefined","getCateCoordinateOfLine","_ref","bandSize","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref2","getBaseValueOfBar","_ref3","numericAxis","getDomainOfSingle","flat","makeDomainFinite","Infinity","getDomainOfStackGroups","stackGroups","startIndex","endIndex","reduce","stackId","group","stackedData","res","sliced","s","MIN_VALUE_REG","MAX_VALUE_REG","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","len","cur","prev","getTooltipEntry","_ref4","tooltipEntrySettings","payload","name","getTooltipNameProp","nameFromItem","calculateCartesianTooltipPos","chartX","chartY","calculatePolarTooltipPos","rangeObj","angle","radius"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNotNil, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n/**\n * Of on four almost identical implementations of tick generation.\n * The four horsemen of tick generation are:\n * - {@link selectTooltipAxisTicks}\n * - {@link combineAxisTicks}\n * - {@link getTicksOfAxis}.\n * - {@link combineGraphicalItemTicks}\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      var scaled = scale.map(scaleContent);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scaled + offset,\n        value: entry,\n        offset,\n        index\n      };\n    }).filter(isNotNil);\n    return result;\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => {\n      var scaled = scale.map(entry);\n      if (!isWellBehavedNumber(scaled)) {\n        return null;\n      }\n      return {\n        coordinate: scaled + offset,\n        value: entry,\n        index,\n        offset\n      };\n    }).filter(isNotNil);\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => {\n    var scaled = scale.map(entry);\n    if (!isWellBehavedNumber(scaled)) {\n      return null;\n    }\n    return {\n      coordinate: scaled + offset,\n      // @ts-expect-error can't use Date as an index\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index,\n      offset\n    };\n  }).filter(isNotNil);\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var _series$;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var series1 = col[1];\n      var series0 = col[0];\n      var value = isNan(series1) ? series0 : series1;\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = negative;\n        negative += value;\n        col[1] = negative;\n      }\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var _series$2;\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  var m = (_series$2 = series[0]) === null || _series$2 === void 0 ? void 0 : _series$2.length;\n  if (m == null || m <= 0) {\n    return;\n  }\n  for (var j = 0; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var row = series[i];\n      var col = row === null || row === void 0 ? void 0 : row[j];\n      if (col == null) {\n        continue;\n      }\n      var value = isNan(col[1]) ? col[0] : col[1];\n      if (value >= 0) {\n        col[0] = positive;\n        positive += value;\n        col[1] = positive;\n      } else {\n        col[0] = 0;\n        col[1] = 0;\n      }\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var _STACK_OFFSET_MAP$off;\n  var offsetAccessor = (_STACK_OFFSET_MAP$off = STACK_OFFSET_MAP[offsetType]) !== null && _STACK_OFFSET_MAP$off !== void 0 ? _STACK_OFFSET_MAP$off : stackOffsetNone;\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  var result = stack(data);\n\n  // Post-process ranged data: if value is an array of two numbers, use them directly without stacking\n  result.forEach((series, seriesIndex) => {\n    series.forEach((point, pointIndex) => {\n      var value = getValueByDataKey(data[pointIndex], dataKeys[seriesIndex], 0);\n      if (Array.isArray(value) && value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[0] = value[0];\n        // eslint-disable-next-line prefer-destructuring,no-param-reassign\n        point[1] = value[1];\n      }\n    });\n  });\n  return result;\n};\n\n/**\n * Externally, we accept both strings and numbers as stack IDs\n * @inline\n */\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks !== null && ticks !== void 0 && ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n  var scaled = axis.scale.map(value);\n  if (!isNumber(scaled)) {\n    return null;\n  }\n  return scaled;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  if (isNullish(value)) {\n    return null;\n  }\n  var scaled = axis.scale.map(value);\n  if (!isNumber(scaled)) {\n    return null;\n  }\n  return scaled - bandSize / 2 + offset;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    if (!group) {\n      return result;\n    }\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      if (!isWellBehavedNumber(s[0]) || !isWellBehavedNumber(s[1])) {\n        return res;\n      }\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min(((cur === null || cur === void 0 ? void 0 : cur.coordinate) || 0) - ((prev === null || prev === void 0 ? void 0 : prev.coordinate) || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}