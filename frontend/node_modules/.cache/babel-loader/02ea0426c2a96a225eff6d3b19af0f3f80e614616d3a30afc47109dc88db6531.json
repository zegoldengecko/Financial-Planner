{"ast":null,"code":"var _excluded = [\"id\"],\n  _excluded2 = [\"activeDot\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"fill\", \"fillOpacity\", \"hide\", \"isAnimationActive\", \"legendType\", \"stroke\", \"xAxisId\", \"yAxisId\"];\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport * as React from 'react';\nimport { PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { Global } from '../util/Global';\nimport { interpolate, isNan, isNullish, isNumber, noop } from '../util/DataUtils';\nimport { getCateCoordinateOfLine, getNormalizedStackId, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { selectArea } from '../state/selectors/areaSelectors';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { useCartesianChartLayout, useChartLayout } from '../context/chartLayoutContext';\nimport { useChartName } from '../state/selectors/selectors';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAppSelector } from '../state/hooks';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { isWellBehavedNumber } from '../util/isWellBehavedNumber';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n\n/**\n * @inline\n */\n\n/**\n * Our base value array has payload in it, and we expose it externally too.\n */\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nfunction getLegendItemColor(stroke, fill) {\n  return stroke && stroke !== 'none' ? stroke : fill;\n}\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    fill,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: getLegendItemColor(stroke, fill),\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nvar SetAreaTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    getPosition: noop,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: getLegendItemColor(stroke, fill),\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\nfunction AreaDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    needClip,\n    dot,\n    dataKey\n  } = props;\n  var areaProps = svgPropertiesNoEvents(props);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-area-dots\",\n    dotClassName: \"recharts-area-dot\",\n    dataKey: dataKey,\n    baseProps: areaProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\nfunction AreaLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = points.map(point => {\n    var _point$x, _point$y;\n    var viewBox = {\n      x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n      y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n      width: 0,\n      lowerWidth: 0,\n      upperWidth: 0,\n      height: 0\n    };\n    return _objectSpread(_objectSpread({}, viewBox), {}, {\n      value: point.value,\n      payload: point.payload,\n      parentViewBox: undefined,\n      viewBox,\n      fill: undefined\n    });\n  });\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\nfunction StaticArea(_ref4) {\n  var {\n    points,\n    baseLine,\n    needClip,\n    clipPathId,\n    props\n  } = _ref4;\n  var {\n    layout,\n    type,\n    stroke,\n    connectNulls,\n    isRange\n  } = props;\n  var {\n      id\n    } = props,\n    propsWithoutId = _objectWithoutProperties(props, _excluded);\n  var allOtherProps = svgPropertiesNoEvents(propsWithoutId);\n  var propsWithEvents = svgPropertiesAndEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Layer, {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined\n  }, /*#__PURE__*/React.createElement(Curve, _extends({}, propsWithEvents, {\n    id: id,\n    points: points,\n    connectNulls: connectNulls,\n    type: type,\n    baseLine: baseLine,\n    layout: layout,\n    stroke: \"none\",\n    className: \"recharts-area-area\"\n  })), stroke !== 'none' && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: points\n  })), stroke !== 'none' && isRange && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: baseLine\n  }))), /*#__PURE__*/React.createElement(AreaDotsWrapper, {\n    points: points,\n    props: propsWithoutId,\n    clipPathId: clipPathId\n  }));\n}\nfunction VerticalRect(_ref5) {\n  var _points$, _points;\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref5;\n  var startY = (_points$ = points[0]) === null || _points$ === void 0 ? void 0 : _points$.y;\n  var endY = (_points = points[points.length - 1]) === null || _points === void 0 ? void 0 : _points.y;\n  if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {\n    return null;\n  }\n  var height = alpha * Math.abs(startY - endY);\n  var maxX = Math.max(...points.map(entry => entry.x || 0));\n  if (isNumber(baseLine)) {\n    maxX = Math.max(baseLine, maxX);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxX = Math.max(...baseLine.map(entry => entry.x || 0), maxX);\n  }\n  if (isNumber(maxX)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: 0,\n      y: startY < endY ? startY : startY - height,\n      width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n      height: Math.floor(height)\n    });\n  }\n  return null;\n}\nfunction HorizontalRect(_ref6) {\n  var _points$2, _points2;\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref6;\n  var startX = (_points$2 = points[0]) === null || _points$2 === void 0 ? void 0 : _points$2.x;\n  var endX = (_points2 = points[points.length - 1]) === null || _points2 === void 0 ? void 0 : _points2.x;\n  if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {\n    return null;\n  }\n  var width = alpha * Math.abs(startX - endX);\n  var maxY = Math.max(...points.map(entry => entry.y || 0));\n  if (isNumber(baseLine)) {\n    maxY = Math.max(baseLine, maxY);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxY = Math.max(...baseLine.map(entry => entry.y || 0), maxY);\n  }\n  if (isNumber(maxY)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: startX < endX ? startX : startX - width,\n      y: 0,\n      width: width,\n      height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n    });\n  }\n  return null;\n}\nfunction ClipRect(_ref7) {\n  var {\n    alpha,\n    layout,\n    points,\n    baseLine,\n    strokeWidth\n  } = _ref7;\n  if (layout === 'vertical') {\n    return /*#__PURE__*/React.createElement(VerticalRect, {\n      alpha: alpha,\n      points: points,\n      baseLine: baseLine,\n      strokeWidth: strokeWidth\n    });\n  }\n  return /*#__PURE__*/React.createElement(HorizontalRect, {\n    alpha: alpha,\n    points: points,\n    baseLine: baseLine,\n    strokeWidth: strokeWidth\n  });\n}\nfunction AreaWithAnimation(_ref8) {\n  var {\n    needClip,\n    clipPathId,\n    props,\n    previousPointsRef,\n    previousBaselineRef\n  } = _ref8;\n  var {\n    points,\n    baseLine,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    onAnimationStart,\n    onAnimationEnd\n  } = props;\n  var animationInput = useMemo(() => ({\n    points,\n    baseLine\n  }), [points, baseLine]);\n  var animationId = useAnimationId(animationInput, 'recharts-area-');\n  var layout = useCartesianChartLayout();\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  if (layout == null) {\n    return null;\n  }\n  var prevPoints = previousPointsRef.current;\n  var prevBaseLine = previousBaselineRef.current;\n  return /*#__PURE__*/React.createElement(AreaLabelListProvider, {\n    showLabels: showLabels,\n    points: points\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepPoints =\n      /*\n       * Here it is important that at the very end of the animation, on the last frame,\n       * we render the original points without any interpolation.\n       * This is needed because the code above is checking for reference equality to decide if the animation should run\n       * and if we create a new array instance (even if the numbers were the same)\n       * then we would break animations.\n       */\n      t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n        return entry;\n      });\n      var stepBaseLine;\n      if (isNumber(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, baseLine, t);\n      } else if (isNullish(baseLine) || isNan(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, 0, t);\n      } else {\n        stepBaseLine = baseLine.map((entry, index) => {\n          var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n          if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {\n            var prev = prevBaseLine[prevPointIndex];\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              x: interpolate(prev.x, entry.x, t),\n              y: interpolate(prev.y, entry.y, t)\n            });\n          }\n          return entry;\n        });\n      }\n      if (t > 0) {\n        /*\n         * We need to keep the refs in the parent component because we need to remember the last shape of the animation\n         * even if AreaWithAnimation is unmounted as that happens when changing props.\n         *\n         * And we need to update the refs here because here is where the interpolation is computed.\n         * Eslint doesn't like changing function arguments, but we need it so here is an eslint-disable.\n         */\n        // eslint-disable-next-line no-param-reassign\n        previousPointsRef.current = stepPoints;\n        // eslint-disable-next-line no-param-reassign\n        previousBaselineRef.current = stepBaseLine;\n      }\n      return /*#__PURE__*/React.createElement(StaticArea, {\n        points: stepPoints,\n        baseLine: stepBaseLine,\n        needClip: needClip,\n        clipPathId: clipPathId,\n        props: props\n      });\n    }\n    if (t > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      // eslint-disable-next-line no-param-reassign\n      previousBaselineRef.current = baseLine;\n    }\n    return /*#__PURE__*/React.createElement(Layer, null, isAnimationActive && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"animationClipPath-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(ClipRect, {\n      alpha: t,\n      points: points,\n      baseLine: baseLine,\n      layout: layout,\n      strokeWidth: props.strokeWidth\n    }))), /*#__PURE__*/React.createElement(Layer, {\n      clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n    }, /*#__PURE__*/React.createElement(StaticArea, {\n      points: points,\n      baseLine: baseLine,\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: props\n    })));\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\n\n/*\n * This components decides if the area should be animated or not.\n * It also holds the state of the animation.\n */\nfunction RenderArea(_ref9) {\n  var {\n    needClip,\n    clipPathId,\n    props\n  } = _ref9;\n  /*\n   * These two must be refs, not state!\n   * Because we want to store the most recent shape of the animation in case we have to interrupt the animation;\n   * that happens when user initiates another animation before the current one finishes.\n   *\n   * If this was a useState, then every step in the animation would trigger a re-render.\n   * So, useRef it is.\n   */\n  var previousPointsRef = useRef(null);\n  var previousBaselineRef = useRef();\n  return /*#__PURE__*/React.createElement(AreaWithAnimation, {\n    needClip: needClip,\n    clipPathId: clipPathId,\n    props: props,\n    previousPointsRef: previousPointsRef,\n    previousBaselineRef: previousBaselineRef\n  });\n}\nclass AreaWithState extends PureComponent {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      top,\n      left,\n      needClip,\n      xAxisId,\n      yAxisId,\n      width,\n      height,\n      id,\n      baseLine,\n      zIndex\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-area', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderArea, {\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: this.props\n    })), /*#__PURE__*/React.createElement(ActivePoints, {\n      points: points,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }), this.props.isRange && Array.isArray(baseLine) && /*#__PURE__*/React.createElement(ActivePoints, {\n      points: baseLine,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }));\n  }\n}\nexport var defaultAreaProps = {\n  activeDot: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: false,\n  fill: '#3182bd',\n  fillOpacity: 0.6,\n  hide: false,\n  isAnimationActive: 'auto',\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  type: 'linear',\n  label: false,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.area\n};\nfunction AreaImpl(props) {\n  var _useAppSelector;\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps),\n    {\n      activeDot,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      fill,\n      fillOpacity,\n      hide,\n      isAnimationActive,\n      legendType,\n      stroke,\n      xAxisId,\n      yAxisId\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n  var layout = useChartLayout();\n  var chartName = useChartName();\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var isPanorama = useIsPanorama();\n  var {\n    points,\n    isRange,\n    baseLine\n  } = (_useAppSelector = useAppSelector(state => selectArea(state, props.id, isPanorama))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};\n  var plotArea = usePlotArea();\n  if (layout !== 'horizontal' && layout !== 'vertical' || plotArea == null) {\n    // Can't render Area in an unsupported layout\n    return null;\n  }\n  if (chartName !== 'AreaChart' && chartName !== 'ComposedChart') {\n    // There is nothing stopping us from rendering Area in other charts, except for historical reasons. Do we want to allow that?\n    return null;\n  }\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n  if (!points || !points.length) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(AreaWithState, _extends({}, everythingElse, {\n    activeDot: activeDot,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    baseLine: baseLine,\n    connectNulls: connectNulls,\n    dot: dot,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    height: height,\n    hide: hide,\n    layout: layout,\n    isAnimationActive: isAnimationActive === 'auto' ? !Global.isSsr : isAnimationActive,\n    isRange: isRange,\n    legendType: legendType,\n    needClip: needClip,\n    points: points,\n    stroke: stroke,\n    width: width,\n    left: left,\n    top: top,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId\n  }));\n}\nexport var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {\n  // The baseValue can be defined both on the AreaChart, and on the Area.\n  // The value for the item takes precedence.\n  var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n  if (isNumber(baseValue)) {\n    return baseValue;\n  }\n  var numericAxis = layout === 'horizontal' ? yAxis : xAxis;\n  // @ts-expect-error d3scale .domain() returns unknown, Math.max expects number\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var domainMax = Math.max(domain[0], domain[1]);\n    var domainMin = Math.min(domain[0], domain[1]);\n    if (baseValue === 'dataMin') {\n      return domainMin;\n    }\n    if (baseValue === 'dataMax') {\n      return domainMax;\n    }\n    return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n  }\n  if (baseValue === 'dataMin') {\n    return domain[0];\n  }\n  if (baseValue === 'dataMax') {\n    return domain[1];\n  }\n  return domain[0];\n};\nexport function computeArea(_ref0) {\n  var {\n    areaSettings: {\n      connectNulls,\n      baseValue: itemBaseValue,\n      dataKey\n    },\n    stackedData,\n    layout,\n    chartBaseValue,\n    xAxis,\n    yAxis,\n    displayedData,\n    dataStartIndex,\n    xAxisTicks,\n    yAxisTicks,\n    bandSize\n  } = _ref0;\n  var hasStack = stackedData && stackedData.length;\n  var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);\n  var isHorizontalLayout = layout === 'horizontal';\n  var isRange = false;\n  var points = displayedData.map((entry, index) => {\n    var _valueAsArray$, _valueAsArray, _xAxis$scale$map;\n    var valueAsArray;\n    if (hasStack) {\n      valueAsArray = stackedData[dataStartIndex + index];\n    } else {\n      var rawValue = getValueByDataKey(entry, dataKey);\n      if (!Array.isArray(rawValue)) {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = [baseValue, rawValue];\n      } else {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = rawValue;\n        isRange = true;\n      }\n    }\n    var value1 = (_valueAsArray$ = (_valueAsArray = valueAsArray) === null || _valueAsArray === void 0 ? void 0 : _valueAsArray[1]) !== null && _valueAsArray$ !== void 0 ? _valueAsArray$ : null;\n    var isBreakPoint = value1 == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;\n    if (isHorizontalLayout) {\n      var _yAxis$scale$map;\n      return {\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isBreakPoint ? null : (_yAxis$scale$map = yAxis.scale.map(value1)) !== null && _yAxis$scale$map !== void 0 ? _yAxis$scale$map : null,\n        value: valueAsArray,\n        payload: entry\n      };\n    }\n    return {\n      x: isBreakPoint ? null : (_xAxis$scale$map = xAxis.scale.map(value1)) !== null && _xAxis$scale$map !== void 0 ? _xAxis$scale$map : null,\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value: valueAsArray,\n      payload: entry\n    };\n  });\n  var baseLine;\n  if (hasStack || isRange) {\n    baseLine = points.map(entry => {\n      var _xAxis$scale$map2;\n      var x = Array.isArray(entry.value) ? entry.value[0] : null;\n      if (isHorizontalLayout) {\n        var _yAxis$scale$map2;\n        return {\n          x: entry.x,\n          y: x != null && entry.y != null ? (_yAxis$scale$map2 = yAxis.scale.map(x)) !== null && _yAxis$scale$map2 !== void 0 ? _yAxis$scale$map2 : null : null,\n          payload: entry.payload\n        };\n      }\n      return {\n        x: x != null ? (_xAxis$scale$map2 = xAxis.scale.map(x)) !== null && _xAxis$scale$map2 !== void 0 ? _xAxis$scale$map2 : null : null,\n        y: entry.y,\n        payload: entry.payload\n      };\n    });\n  } else {\n    baseLine = isHorizontalLayout ? yAxis.scale.map(baseValue) : xAxis.scale.map(baseValue);\n  }\n  return {\n    points,\n    baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : 0,\n    isRange\n  };\n}\nfunction AreaFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultAreaProps);\n  var isPanorama = useIsPanorama();\n  // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"area\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetAreaTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"area\",\n    id: id,\n    data: props.data,\n    dataKey: props.dataKey,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    stackId: getNormalizedStackId(props.stackId),\n    hide: props.hide,\n    barSize: undefined,\n    baseValue: props.baseValue,\n    isPanorama: isPanorama,\n    connectNulls: props.connectNulls\n  }), /*#__PURE__*/React.createElement(AreaImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n\n/**\n * @provides LabelListContext\n * @consumes CartesianChartContext\n */\nexport var Area = /*#__PURE__*/React.memo(AreaFn, propsAreEqual);\nArea.displayName = 'Area';","map":{"version":3,"names":["_excluded","_excluded2","_extends","Object","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","_objectWithoutProperties","o","i","_objectWithoutPropertiesLoose","getOwnPropertySymbols","indexOf","propertyIsEnumerable","ownKeys","keys","filter","getOwnPropertyDescriptor","enumerable","push","_objectSpread","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","React","PureComponent","useCallback","useMemo","useRef","useState","clsx","Curve","Layer","CartesianLabelListContextProvider","LabelListFromLabelProp","Dots","Global","interpolate","isNan","isNullish","isNumber","noop","getCateCoordinateOfLine","getNormalizedStackId","getTooltipNameProp","getValueByDataKey","isClipDot","ActivePoints","SetTooltipEntrySettings","GraphicalItemClipPath","useNeedsClip","selectArea","useIsPanorama","useCartesianChartLayout","useChartLayout","useChartName","SetLegendPayload","useAppSelector","useAnimationId","resolveDefaultProps","isWellBehavedNumber","usePlotArea","RegisterGraphicalItemId","SetCartesianGraphicalItem","svgPropertiesNoEvents","JavascriptAnimate","getRadiusAndStrokeWidthFromDot","svgPropertiesAndEvents","ZIndexLayer","DefaultZIndexes","propsAreEqual","getLegendItemColor","stroke","fill","computeLegendPayloadFromAreaData","props","dataKey","name","legendType","hide","inactive","type","color","payload","SetAreaTooltipEntrySettings","memo","_ref","data","strokeWidth","unit","tooltipType","id","tooltipEntrySettings","dataDefinedOnItem","getPosition","settings","nameKey","undefined","graphicalItemId","createElement","AreaDotsWrapper","_ref2","clipPathId","points","needClip","dot","areaProps","className","dotClassName","baseProps","AreaLabelListProvider","_ref3","showLabels","children","labelListEntries","map","point","_point$x","_point$y","viewBox","x","y","width","lowerWidth","upperWidth","height","parentViewBox","StaticArea","_ref4","baseLine","layout","connectNulls","isRange","propsWithoutId","allOtherProps","propsWithEvents","Fragment","clipPath","concat","VerticalRect","_ref5","_points$","_points","alpha","startY","endY","Math","abs","maxX","max","entry","Array","isArray","parseInt","floor","HorizontalRect","_ref6","_points$2","_points2","startX","endX","maxY","ClipRect","_ref7","AreaWithAnimation","_ref8","previousPointsRef","previousBaselineRef","isAnimationActive","animationBegin","animationDuration","animationEasing","onAnimationStart","onAnimationEnd","animationInput","animationId","isAnimating","setIsAnimating","handleAnimationEnd","handleAnimationStart","prevPoints","current","prevBaseLine","begin","duration","isActive","easing","key","prevPointsDiffFactor","stepPoints","index","prevPointIndex","prev","stepBaseLine","label","RenderArea","_ref9","AreaWithState","render","top","left","xAxisId","yAxisId","zIndex","layerClass","clipDot","dotSize","activePointsClipPath","mainColor","itemDataKey","activeDot","defaultAreaProps","fillOpacity","area","AreaImpl","_useAppSelector","_resolveDefaultProps","everythingElse","chartName","isPanorama","state","plotArea","isSsr","getBaseValue","chartBaseValue","itemBaseValue","xAxis","yAxis","baseValue","numericAxis","domain","scale","domainMax","domainMin","min","computeArea","_ref0","areaSettings","stackedData","displayedData","dataStartIndex","xAxisTicks","yAxisTicks","bandSize","hasStack","isHorizontalLayout","_valueAsArray$","_valueAsArray","_xAxis$scale$map","valueAsArray","rawValue","value1","isBreakPoint","_yAxis$scale$map","axis","ticks","_xAxis$scale$map2","_yAxis$scale$map2","AreaFn","outsideProps","legendPayload","zAxisId","stackId","barSize","Area","displayName"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/cartesian/Area.js"],"sourcesContent":["var _excluded = [\"id\"],\n  _excluded2 = [\"activeDot\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"fill\", \"fillOpacity\", \"hide\", \"isAnimationActive\", \"legendType\", \"stroke\", \"xAxisId\", \"yAxisId\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport * as React from 'react';\nimport { PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Layer } from '../container/Layer';\nimport { CartesianLabelListContextProvider, LabelListFromLabelProp } from '../component/LabelList';\nimport { Dots } from '../component/Dots';\nimport { Global } from '../util/Global';\nimport { interpolate, isNan, isNullish, isNumber, noop } from '../util/DataUtils';\nimport { getCateCoordinateOfLine, getNormalizedStackId, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { isClipDot } from '../util/ReactUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { selectArea } from '../state/selectors/areaSelectors';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { useCartesianChartLayout, useChartLayout } from '../context/chartLayoutContext';\nimport { useChartName } from '../state/selectors/selectors';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAppSelector } from '../state/hooks';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { isWellBehavedNumber } from '../util/isWellBehavedNumber';\nimport { usePlotArea } from '../hooks';\nimport { RegisterGraphicalItemId } from '../context/RegisterGraphicalItemId';\nimport { SetCartesianGraphicalItem } from '../state/SetGraphicalItem';\nimport { svgPropertiesNoEvents } from '../util/svgPropertiesNoEvents';\nimport { JavascriptAnimate } from '../animation/JavascriptAnimate';\nimport { getRadiusAndStrokeWidthFromDot } from '../util/getRadiusAndStrokeWidthFromDot';\nimport { svgPropertiesAndEvents } from '../util/svgPropertiesAndEvents';\nimport { ZIndexLayer } from '../zIndex/ZIndexLayer';\nimport { DefaultZIndexes } from '../zIndex/DefaultZIndexes';\nimport { propsAreEqual } from '../util/propsAreEqual';\n\n/**\n * @inline\n */\n\n/**\n * Our base value array has payload in it, and we expose it externally too.\n */\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nfunction getLegendItemColor(stroke, fill) {\n  return stroke && stroke !== 'none' ? stroke : fill;\n}\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    fill,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: getLegendItemColor(stroke, fill),\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nvar SetAreaTooltipEntrySettings = /*#__PURE__*/React.memo(_ref => {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit,\n    tooltipType,\n    id\n  } = _ref;\n  var tooltipEntrySettings = {\n    dataDefinedOnItem: data,\n    getPosition: noop,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: tooltipType,\n      color: getLegendItemColor(stroke, fill),\n      unit,\n      graphicalItemId: id\n    }\n  };\n  return /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n    tooltipEntrySettings: tooltipEntrySettings\n  });\n});\nfunction AreaDotsWrapper(_ref2) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref2;\n  var {\n    needClip,\n    dot,\n    dataKey\n  } = props;\n  var areaProps = svgPropertiesNoEvents(props);\n  return /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    dot: dot,\n    className: \"recharts-area-dots\",\n    dotClassName: \"recharts-area-dot\",\n    dataKey: dataKey,\n    baseProps: areaProps,\n    needClip: needClip,\n    clipPathId: clipPathId\n  });\n}\nfunction AreaLabelListProvider(_ref3) {\n  var {\n    showLabels,\n    children,\n    points\n  } = _ref3;\n  var labelListEntries = points.map(point => {\n    var _point$x, _point$y;\n    var viewBox = {\n      x: (_point$x = point.x) !== null && _point$x !== void 0 ? _point$x : 0,\n      y: (_point$y = point.y) !== null && _point$y !== void 0 ? _point$y : 0,\n      width: 0,\n      lowerWidth: 0,\n      upperWidth: 0,\n      height: 0\n    };\n    return _objectSpread(_objectSpread({}, viewBox), {}, {\n      value: point.value,\n      payload: point.payload,\n      parentViewBox: undefined,\n      viewBox,\n      fill: undefined\n    });\n  });\n  return /*#__PURE__*/React.createElement(CartesianLabelListContextProvider, {\n    value: showLabels ? labelListEntries : undefined\n  }, children);\n}\nfunction StaticArea(_ref4) {\n  var {\n    points,\n    baseLine,\n    needClip,\n    clipPathId,\n    props\n  } = _ref4;\n  var {\n    layout,\n    type,\n    stroke,\n    connectNulls,\n    isRange\n  } = props;\n  var {\n      id\n    } = props,\n    propsWithoutId = _objectWithoutProperties(props, _excluded);\n  var allOtherProps = svgPropertiesNoEvents(propsWithoutId);\n  var propsWithEvents = svgPropertiesAndEvents(propsWithoutId);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Layer, {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined\n  }, /*#__PURE__*/React.createElement(Curve, _extends({}, propsWithEvents, {\n    id: id,\n    points: points,\n    connectNulls: connectNulls,\n    type: type,\n    baseLine: baseLine,\n    layout: layout,\n    stroke: \"none\",\n    className: \"recharts-area-area\"\n  })), stroke !== 'none' && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: points\n  })), stroke !== 'none' && isRange && /*#__PURE__*/React.createElement(Curve, _extends({}, allOtherProps, {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: baseLine\n  }))), /*#__PURE__*/React.createElement(AreaDotsWrapper, {\n    points: points,\n    props: propsWithoutId,\n    clipPathId: clipPathId\n  }));\n}\nfunction VerticalRect(_ref5) {\n  var _points$, _points;\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref5;\n  var startY = (_points$ = points[0]) === null || _points$ === void 0 ? void 0 : _points$.y;\n  var endY = (_points = points[points.length - 1]) === null || _points === void 0 ? void 0 : _points.y;\n  if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {\n    return null;\n  }\n  var height = alpha * Math.abs(startY - endY);\n  var maxX = Math.max(...points.map(entry => entry.x || 0));\n  if (isNumber(baseLine)) {\n    maxX = Math.max(baseLine, maxX);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxX = Math.max(...baseLine.map(entry => entry.x || 0), maxX);\n  }\n  if (isNumber(maxX)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: 0,\n      y: startY < endY ? startY : startY - height,\n      width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n      height: Math.floor(height)\n    });\n  }\n  return null;\n}\nfunction HorizontalRect(_ref6) {\n  var _points$2, _points2;\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref6;\n  var startX = (_points$2 = points[0]) === null || _points$2 === void 0 ? void 0 : _points$2.x;\n  var endX = (_points2 = points[points.length - 1]) === null || _points2 === void 0 ? void 0 : _points2.x;\n  if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {\n    return null;\n  }\n  var width = alpha * Math.abs(startX - endX);\n  var maxY = Math.max(...points.map(entry => entry.y || 0));\n  if (isNumber(baseLine)) {\n    maxY = Math.max(baseLine, maxY);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxY = Math.max(...baseLine.map(entry => entry.y || 0), maxY);\n  }\n  if (isNumber(maxY)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: startX < endX ? startX : startX - width,\n      y: 0,\n      width: width,\n      height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n    });\n  }\n  return null;\n}\nfunction ClipRect(_ref7) {\n  var {\n    alpha,\n    layout,\n    points,\n    baseLine,\n    strokeWidth\n  } = _ref7;\n  if (layout === 'vertical') {\n    return /*#__PURE__*/React.createElement(VerticalRect, {\n      alpha: alpha,\n      points: points,\n      baseLine: baseLine,\n      strokeWidth: strokeWidth\n    });\n  }\n  return /*#__PURE__*/React.createElement(HorizontalRect, {\n    alpha: alpha,\n    points: points,\n    baseLine: baseLine,\n    strokeWidth: strokeWidth\n  });\n}\nfunction AreaWithAnimation(_ref8) {\n  var {\n    needClip,\n    clipPathId,\n    props,\n    previousPointsRef,\n    previousBaselineRef\n  } = _ref8;\n  var {\n    points,\n    baseLine,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    onAnimationStart,\n    onAnimationEnd\n  } = props;\n  var animationInput = useMemo(() => ({\n    points,\n    baseLine\n  }), [points, baseLine]);\n  var animationId = useAnimationId(animationInput, 'recharts-area-');\n  var layout = useCartesianChartLayout();\n  var [isAnimating, setIsAnimating] = useState(false);\n  var showLabels = !isAnimating;\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  if (layout == null) {\n    return null;\n  }\n  var prevPoints = previousPointsRef.current;\n  var prevBaseLine = previousBaselineRef.current;\n  return /*#__PURE__*/React.createElement(AreaLabelListProvider, {\n    showLabels: showLabels,\n    points: points\n  }, props.children, /*#__PURE__*/React.createElement(JavascriptAnimate, {\n    animationId: animationId,\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, t => {\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepPoints =\n      /*\n       * Here it is important that at the very end of the animation, on the last frame,\n       * we render the original points without any interpolation.\n       * This is needed because the code above is checking for reference equality to decide if the animation should run\n       * and if we create a new array instance (even if the numbers were the same)\n       * then we would break animations.\n       */\n      t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n        return entry;\n      });\n      var stepBaseLine;\n      if (isNumber(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, baseLine, t);\n      } else if (isNullish(baseLine) || isNan(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, 0, t);\n      } else {\n        stepBaseLine = baseLine.map((entry, index) => {\n          var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n          if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {\n            var prev = prevBaseLine[prevPointIndex];\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              x: interpolate(prev.x, entry.x, t),\n              y: interpolate(prev.y, entry.y, t)\n            });\n          }\n          return entry;\n        });\n      }\n      if (t > 0) {\n        /*\n         * We need to keep the refs in the parent component because we need to remember the last shape of the animation\n         * even if AreaWithAnimation is unmounted as that happens when changing props.\n         *\n         * And we need to update the refs here because here is where the interpolation is computed.\n         * Eslint doesn't like changing function arguments, but we need it so here is an eslint-disable.\n         */\n        // eslint-disable-next-line no-param-reassign\n        previousPointsRef.current = stepPoints;\n        // eslint-disable-next-line no-param-reassign\n        previousBaselineRef.current = stepBaseLine;\n      }\n      return /*#__PURE__*/React.createElement(StaticArea, {\n        points: stepPoints,\n        baseLine: stepBaseLine,\n        needClip: needClip,\n        clipPathId: clipPathId,\n        props: props\n      });\n    }\n    if (t > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      // eslint-disable-next-line no-param-reassign\n      previousBaselineRef.current = baseLine;\n    }\n    return /*#__PURE__*/React.createElement(Layer, null, isAnimationActive && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"animationClipPath-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(ClipRect, {\n      alpha: t,\n      points: points,\n      baseLine: baseLine,\n      layout: layout,\n      strokeWidth: props.strokeWidth\n    }))), /*#__PURE__*/React.createElement(Layer, {\n      clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n    }, /*#__PURE__*/React.createElement(StaticArea, {\n      points: points,\n      baseLine: baseLine,\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: props\n    })));\n  }), /*#__PURE__*/React.createElement(LabelListFromLabelProp, {\n    label: props.label\n  }));\n}\n\n/*\n * This components decides if the area should be animated or not.\n * It also holds the state of the animation.\n */\nfunction RenderArea(_ref9) {\n  var {\n    needClip,\n    clipPathId,\n    props\n  } = _ref9;\n  /*\n   * These two must be refs, not state!\n   * Because we want to store the most recent shape of the animation in case we have to interrupt the animation;\n   * that happens when user initiates another animation before the current one finishes.\n   *\n   * If this was a useState, then every step in the animation would trigger a re-render.\n   * So, useRef it is.\n   */\n  var previousPointsRef = useRef(null);\n  var previousBaselineRef = useRef();\n  return /*#__PURE__*/React.createElement(AreaWithAnimation, {\n    needClip: needClip,\n    clipPathId: clipPathId,\n    props: props,\n    previousPointsRef: previousPointsRef,\n    previousBaselineRef: previousBaselineRef\n  });\n}\nclass AreaWithState extends PureComponent {\n  render() {\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      top,\n      left,\n      needClip,\n      xAxisId,\n      yAxisId,\n      width,\n      height,\n      id,\n      baseLine,\n      zIndex\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-area', className);\n    var clipPathId = id;\n    var {\n      r,\n      strokeWidth\n    } = getRadiusAndStrokeWidthFromDot(dot);\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    var activePointsClipPath = needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined;\n    return /*#__PURE__*/React.createElement(ZIndexLayer, {\n      zIndex: zIndex\n    }, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderArea, {\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: this.props\n    })), /*#__PURE__*/React.createElement(ActivePoints, {\n      points: points,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }), this.props.isRange && Array.isArray(baseLine) && /*#__PURE__*/React.createElement(ActivePoints, {\n      points: baseLine,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot,\n      clipPath: activePointsClipPath\n    }));\n  }\n}\nexport var defaultAreaProps = {\n  activeDot: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: false,\n  fill: '#3182bd',\n  fillOpacity: 0.6,\n  hide: false,\n  isAnimationActive: 'auto',\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  type: 'linear',\n  label: false,\n  xAxisId: 0,\n  yAxisId: 0,\n  zIndex: DefaultZIndexes.area\n};\nfunction AreaImpl(props) {\n  var _useAppSelector;\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps),\n    {\n      activeDot,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      fill,\n      fillOpacity,\n      hide,\n      isAnimationActive,\n      legendType,\n      stroke,\n      xAxisId,\n      yAxisId\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n  var layout = useChartLayout();\n  var chartName = useChartName();\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var isPanorama = useIsPanorama();\n  var {\n    points,\n    isRange,\n    baseLine\n  } = (_useAppSelector = useAppSelector(state => selectArea(state, props.id, isPanorama))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};\n  var plotArea = usePlotArea();\n  if (layout !== 'horizontal' && layout !== 'vertical' || plotArea == null) {\n    // Can't render Area in an unsupported layout\n    return null;\n  }\n  if (chartName !== 'AreaChart' && chartName !== 'ComposedChart') {\n    // There is nothing stopping us from rendering Area in other charts, except for historical reasons. Do we want to allow that?\n    return null;\n  }\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = plotArea;\n  if (!points || !points.length) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(AreaWithState, _extends({}, everythingElse, {\n    activeDot: activeDot,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    baseLine: baseLine,\n    connectNulls: connectNulls,\n    dot: dot,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    height: height,\n    hide: hide,\n    layout: layout,\n    isAnimationActive: isAnimationActive === 'auto' ? !Global.isSsr : isAnimationActive,\n    isRange: isRange,\n    legendType: legendType,\n    needClip: needClip,\n    points: points,\n    stroke: stroke,\n    width: width,\n    left: left,\n    top: top,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId\n  }));\n}\nexport var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {\n  // The baseValue can be defined both on the AreaChart, and on the Area.\n  // The value for the item takes precedence.\n  var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n  if (isNumber(baseValue)) {\n    return baseValue;\n  }\n  var numericAxis = layout === 'horizontal' ? yAxis : xAxis;\n  // @ts-expect-error d3scale .domain() returns unknown, Math.max expects number\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var domainMax = Math.max(domain[0], domain[1]);\n    var domainMin = Math.min(domain[0], domain[1]);\n    if (baseValue === 'dataMin') {\n      return domainMin;\n    }\n    if (baseValue === 'dataMax') {\n      return domainMax;\n    }\n    return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n  }\n  if (baseValue === 'dataMin') {\n    return domain[0];\n  }\n  if (baseValue === 'dataMax') {\n    return domain[1];\n  }\n  return domain[0];\n};\nexport function computeArea(_ref0) {\n  var {\n    areaSettings: {\n      connectNulls,\n      baseValue: itemBaseValue,\n      dataKey\n    },\n    stackedData,\n    layout,\n    chartBaseValue,\n    xAxis,\n    yAxis,\n    displayedData,\n    dataStartIndex,\n    xAxisTicks,\n    yAxisTicks,\n    bandSize\n  } = _ref0;\n  var hasStack = stackedData && stackedData.length;\n  var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);\n  var isHorizontalLayout = layout === 'horizontal';\n  var isRange = false;\n  var points = displayedData.map((entry, index) => {\n    var _valueAsArray$, _valueAsArray, _xAxis$scale$map;\n    var valueAsArray;\n    if (hasStack) {\n      valueAsArray = stackedData[dataStartIndex + index];\n    } else {\n      var rawValue = getValueByDataKey(entry, dataKey);\n      if (!Array.isArray(rawValue)) {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = [baseValue, rawValue];\n      } else {\n        // @ts-expect-error getValueByDataKey is not checking its return value\n        valueAsArray = rawValue;\n        isRange = true;\n      }\n    }\n    var value1 = (_valueAsArray$ = (_valueAsArray = valueAsArray) === null || _valueAsArray === void 0 ? void 0 : _valueAsArray[1]) !== null && _valueAsArray$ !== void 0 ? _valueAsArray$ : null;\n    var isBreakPoint = value1 == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;\n    if (isHorizontalLayout) {\n      var _yAxis$scale$map;\n      return {\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isBreakPoint ? null : (_yAxis$scale$map = yAxis.scale.map(value1)) !== null && _yAxis$scale$map !== void 0 ? _yAxis$scale$map : null,\n        value: valueAsArray,\n        payload: entry\n      };\n    }\n    return {\n      x: isBreakPoint ? null : (_xAxis$scale$map = xAxis.scale.map(value1)) !== null && _xAxis$scale$map !== void 0 ? _xAxis$scale$map : null,\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value: valueAsArray,\n      payload: entry\n    };\n  });\n  var baseLine;\n  if (hasStack || isRange) {\n    baseLine = points.map(entry => {\n      var _xAxis$scale$map2;\n      var x = Array.isArray(entry.value) ? entry.value[0] : null;\n      if (isHorizontalLayout) {\n        var _yAxis$scale$map2;\n        return {\n          x: entry.x,\n          y: x != null && entry.y != null ? (_yAxis$scale$map2 = yAxis.scale.map(x)) !== null && _yAxis$scale$map2 !== void 0 ? _yAxis$scale$map2 : null : null,\n          payload: entry.payload\n        };\n      }\n      return {\n        x: x != null ? (_xAxis$scale$map2 = xAxis.scale.map(x)) !== null && _xAxis$scale$map2 !== void 0 ? _xAxis$scale$map2 : null : null,\n        y: entry.y,\n        payload: entry.payload\n      };\n    });\n  } else {\n    baseLine = isHorizontalLayout ? yAxis.scale.map(baseValue) : xAxis.scale.map(baseValue);\n  }\n  return {\n    points,\n    baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : 0,\n    isRange\n  };\n}\nfunction AreaFn(outsideProps) {\n  var props = resolveDefaultProps(outsideProps, defaultAreaProps);\n  var isPanorama = useIsPanorama();\n  // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n  return /*#__PURE__*/React.createElement(RegisterGraphicalItemId, {\n    id: props.id,\n    type: \"area\"\n  }, id => /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(SetLegendPayload, {\n    legendPayload: computeLegendPayloadFromAreaData(props)\n  }), /*#__PURE__*/React.createElement(SetAreaTooltipEntrySettings, {\n    dataKey: props.dataKey,\n    data: props.data,\n    stroke: props.stroke,\n    strokeWidth: props.strokeWidth,\n    fill: props.fill,\n    name: props.name,\n    hide: props.hide,\n    unit: props.unit,\n    tooltipType: props.tooltipType,\n    id: id\n  }), /*#__PURE__*/React.createElement(SetCartesianGraphicalItem, {\n    type: \"area\",\n    id: id,\n    data: props.data,\n    dataKey: props.dataKey,\n    xAxisId: props.xAxisId,\n    yAxisId: props.yAxisId,\n    zAxisId: 0,\n    stackId: getNormalizedStackId(props.stackId),\n    hide: props.hide,\n    barSize: undefined,\n    baseValue: props.baseValue,\n    isPanorama: isPanorama,\n    connectNulls: props.connectNulls\n  }), /*#__PURE__*/React.createElement(AreaImpl, _extends({}, props, {\n    id: id\n  }))));\n}\n\n/**\n * @provides LabelListContext\n * @consumes CartesianChartContext\n */\nexport var Area = /*#__PURE__*/React.memo(AreaFn, propsAreEqual);\nArea.displayName = 'Area';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}