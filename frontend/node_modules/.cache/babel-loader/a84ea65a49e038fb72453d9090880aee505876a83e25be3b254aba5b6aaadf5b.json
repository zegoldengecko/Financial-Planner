{"ast":null,"code":"/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max];\n\n  // exchange\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n  return [validMin, validMax];\n};\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n  var digitCount = getDigitCount(roughStep.toNumber());\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1);\n  // calculate the middle value of ticks\n  var middle = new Decimal(value);\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var ticks = [];\n  for (var i = 0; i < tickCount; i++) {\n    ticks.push(middle.add(new Decimal(i - middleIndex).mul(step)).toNumber());\n  }\n  return ticks;\n};\n\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  }\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor);\n\n  // A medial value of ticks\n  var middle;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2);\n    // minus modulo value\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport { _calculateStep as calculateStep };\nexport var getNiceTickValues = function getNiceTickValues(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...Array(tickCount - 1).fill(Infinity)] : [...Array(tickCount - 1).fill(-Infinity), cormax];\n    return min > max ? _values.reverse() : _values;\n  }\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? values.reverse() : values;\n};\n\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickValuesFixedDomain = function getTickValuesFixedDomain(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n  if (cormin === cormax) {\n    return [cormin];\n  }\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n  return min > max ? values.reverse() : values;\n};","map":{"version":3,"names":["Decimal","getDigitCount","rangeStep","getValidInterval","_ref","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","lte","digitCount","toNumber","digitCountValue","pow","stepRatio","div","stepRatioScale","amendStepRatio","Math","ceil","add","mul","formatStep","getTickOfSingleValue","value","tickCount","step","middle","isint","absVal","abs","floor","middleIndex","ticks","i","push","_calculateStep","calculateStep","arguments","length","undefined","Number","isFinite","tickMin","tickMax","sub","mod","belowCount","upCount","scaleCount","getNiceTickValues","_ref2","count","cormin","cormax","Infinity","_values","Array","fill","reverse","values","getTickValuesFixedDomain","_ref3","map","round"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/util/scale/getNiceTickValues.js"],"sourcesContent":["/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max];\n\n  // exchange\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n  return [validMin, validMax];\n};\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n  var digitCount = getDigitCount(roughStep.toNumber());\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1);\n  // calculate the middle value of ticks\n  var middle = new Decimal(value);\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var ticks = [];\n  for (var i = 0; i < tickCount; i++) {\n    ticks.push(middle.add(new Decimal(i - middleIndex).mul(step)).toNumber());\n  }\n  return ticks;\n};\n\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  }\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor);\n\n  // A medial value of ticks\n  var middle;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2);\n    // minus modulo value\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport { _calculateStep as calculateStep };\nexport var getNiceTickValues = function getNiceTickValues(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...Array(tickCount - 1).fill(Infinity)] : [...Array(tickCount - 1).fill(-Infinity), cormax];\n    return min > max ? _values.reverse() : _values;\n  }\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? values.reverse() : values;\n};\n\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickValuesFixedDomain = function getTickValuesFixedDomain(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n  if (cormin === cormax) {\n    return [cormin];\n  }\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n  return min > max ? values.reverse() : values;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}