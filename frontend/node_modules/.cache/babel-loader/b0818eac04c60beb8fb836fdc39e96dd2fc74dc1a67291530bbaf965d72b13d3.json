{"ast":null,"code":"import { createSelector } from 'reselect';\nimport { selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectBarRectangles } from './barSelectors';\nvar pickStackId = (state, stackId) => stackId;\nvar pickIsPanorama = (state, stackId, isPanorama) => isPanorama;\nexport var selectAllBarsInStack = createSelector([pickStackId, selectUnfilteredCartesianItems, pickIsPanorama], (stackId, allItems, isPanorama) => {\n  return allItems.filter(i => i.type === 'bar').filter(i => i.stackId === stackId).filter(i => i.isPanorama === isPanorama).filter(i => !i.hide);\n});\nvar selectAllBarIdsInStack = createSelector([selectAllBarsInStack], allBars => {\n  return allBars.map(bar => bar.id);\n});\n/**\n * Takes two rectangles and returns a new rectangle that encompasses both.\n * It takes the minimum x and y, and the maximum width and height.\n * It handles overlapping rectangles, and rectangles with a gap between them.\n * @param rect1\n * @param rect2\n */\nexport var expandRectangle = (rect1, rect2) => {\n  if (!rect1) {\n    return rect2;\n  }\n  if (!rect2) {\n    return rect1;\n  }\n  var x = Math.min(rect1.x, rect1.x + rect1.width, rect2.x, rect2.x + rect2.width);\n  var y = Math.min(rect1.y, rect1.y + rect1.height, rect2.y, rect2.y + rect2.height);\n  var maxX = Math.max(rect1.x, rect1.x + rect1.width, rect2.x, rect2.x + rect2.width);\n  var maxY = Math.max(rect1.y, rect1.y + rect1.height, rect2.y, rect2.y + rect2.height);\n  var width = maxX - x;\n  var height = maxY - y;\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n};\nvar combineStackRects = (state, stackId, isPanorama) => {\n  var allBarIds = selectAllBarIdsInStack(state, stackId, isPanorama);\n  var stackRects = [];\n  allBarIds.forEach(barId => {\n    var rectangles = selectBarRectangles(state, barId, isPanorama, undefined);\n    rectangles === null || rectangles === void 0 || rectangles.forEach((rect, index) => {\n      stackRects[index] = expandRectangle(stackRects[index], rect);\n    });\n  });\n  return stackRects;\n};\nexport var selectStackRects = createSelector([state => state, pickStackId, pickIsPanorama], combineStackRects);","map":{"version":3,"names":["createSelector","selectUnfilteredCartesianItems","selectBarRectangles","pickStackId","state","stackId","pickIsPanorama","isPanorama","selectAllBarsInStack","allItems","filter","i","type","hide","selectAllBarIdsInStack","allBars","map","bar","id","expandRectangle","rect1","rect2","x","Math","min","width","y","height","maxX","max","maxY","combineStackRects","allBarIds","stackRects","forEach","barId","rectangles","undefined","rect","index","selectStackRects"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/state/selectors/barStackSelectors.js"],"sourcesContent":["import { createSelector } from 'reselect';\nimport { selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectBarRectangles } from './barSelectors';\nvar pickStackId = (state, stackId) => stackId;\nvar pickIsPanorama = (state, stackId, isPanorama) => isPanorama;\nexport var selectAllBarsInStack = createSelector([pickStackId, selectUnfilteredCartesianItems, pickIsPanorama], (stackId, allItems, isPanorama) => {\n  return allItems.filter(i => i.type === 'bar').filter(i => i.stackId === stackId).filter(i => i.isPanorama === isPanorama).filter(i => !i.hide);\n});\nvar selectAllBarIdsInStack = createSelector([selectAllBarsInStack], allBars => {\n  return allBars.map(bar => bar.id);\n});\n/**\n * Takes two rectangles and returns a new rectangle that encompasses both.\n * It takes the minimum x and y, and the maximum width and height.\n * It handles overlapping rectangles, and rectangles with a gap between them.\n * @param rect1\n * @param rect2\n */\nexport var expandRectangle = (rect1, rect2) => {\n  if (!rect1) {\n    return rect2;\n  }\n  if (!rect2) {\n    return rect1;\n  }\n  var x = Math.min(rect1.x, rect1.x + rect1.width, rect2.x, rect2.x + rect2.width);\n  var y = Math.min(rect1.y, rect1.y + rect1.height, rect2.y, rect2.y + rect2.height);\n  var maxX = Math.max(rect1.x, rect1.x + rect1.width, rect2.x, rect2.x + rect2.width);\n  var maxY = Math.max(rect1.y, rect1.y + rect1.height, rect2.y, rect2.y + rect2.height);\n  var width = maxX - x;\n  var height = maxY - y;\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n};\nvar combineStackRects = (state, stackId, isPanorama) => {\n  var allBarIds = selectAllBarIdsInStack(state, stackId, isPanorama);\n  var stackRects = [];\n  allBarIds.forEach(barId => {\n    var rectangles = selectBarRectangles(state, barId, isPanorama, undefined);\n    rectangles === null || rectangles === void 0 || rectangles.forEach((rect, index) => {\n      stackRects[index] = expandRectangle(stackRects[index], rect);\n    });\n  });\n  return stackRects;\n};\nexport var selectStackRects = createSelector([state => state, pickStackId, pickIsPanorama], combineStackRects);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}