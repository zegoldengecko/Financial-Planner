{"ast":null,"code":"import { createSelector } from 'reselect';\nimport { computeArea } from '../../cartesian/Area';\nimport { selectAxisWithScale, selectStackGroups, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectChartDataWithIndexesIfNotInPanoramaPosition3 } from './dataSelectors';\nimport { getBandSizeOfAxis, isCategoricalAxis } from '../../util/ChartUtils';\nimport { getStackSeriesIdentifier } from '../../util/stacks/getStackSeriesIdentifier';\nimport { selectChartBaseValue } from './rootPropsSelectors';\nimport { selectXAxisIdFromGraphicalItemId, selectYAxisIdFromGraphicalItemId } from './graphicalItemSelectors';\nvar selectXAxisWithScale = (state, graphicalItemId, isPanorama) => selectAxisWithScale(state, 'xAxis', selectXAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectXAxisTicks = (state, graphicalItemId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', selectXAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectYAxisWithScale = (state, graphicalItemId, isPanorama) => selectAxisWithScale(state, 'yAxis', selectYAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectYAxisTicks = (state, graphicalItemId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', selectYAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\nvar pickAreaId = (_state, id) => id;\n\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\nvar selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaId], (graphicalItems, id) => graphicalItems.filter(item => item.type === 'area').find(item => item.id === id));\nvar selectNumericalAxisType = state => {\n  var layout = selectChartLayout(state);\n  var isXAxisCategorical = isCategoricalAxis(layout, 'xAxis');\n  return isXAxisCategorical ? 'yAxis' : 'xAxis';\n};\nvar selectNumericalAxisIdFromGraphicalItemId = (state, graphicalItemId) => {\n  var axisType = selectNumericalAxisType(state);\n  if (axisType === 'yAxis') {\n    return selectYAxisIdFromGraphicalItemId(state, graphicalItemId);\n  }\n  return selectXAxisIdFromGraphicalItemId(state, graphicalItemId);\n};\nvar selectNumericalAxisStackGroups = (state, graphicalItemId, isPanorama) => selectStackGroups(state, selectNumericalAxisType(state), selectNumericalAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nexport var selectGraphicalItemStackedData = createSelector([selectSynchronisedAreaSettings, selectNumericalAxisStackGroups], (areaSettings, stackGroups) => {\n  var _stackGroups$stackId;\n  if (areaSettings == null || stackGroups == null) {\n    return undefined;\n  }\n  var {\n    stackId\n  } = areaSettings;\n  var stackSeriesIdentifier = getStackSeriesIdentifier(areaSettings);\n  if (stackId == null || stackSeriesIdentifier == null) {\n    return undefined;\n  }\n  var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;\n  var found = groups === null || groups === void 0 ? void 0 : groups.find(v => v.key === stackSeriesIdentifier);\n  if (found == null) {\n    return undefined;\n  }\n  return found.map(item => [item[0], item[1]]);\n});\nexport var selectArea = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanoramaPosition3, selectBandSize, selectSynchronisedAreaSettings, selectChartBaseValue], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref, bandSize, areaSettings, chartBaseValue) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (areaSettings == null || layout !== 'horizontal' && layout !== 'vertical' || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n  var {\n    data\n  } = areaSettings;\n  var displayedData;\n  if (data && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n  if (displayedData == null) {\n    return undefined;\n  }\n  return computeArea({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataStartIndex,\n    areaSettings,\n    stackedData,\n    displayedData,\n    chartBaseValue,\n    bandSize\n  });\n});","map":{"version":3,"names":["createSelector","computeArea","selectAxisWithScale","selectStackGroups","selectTicksOfGraphicalItem","selectUnfilteredCartesianItems","selectChartLayout","selectChartDataWithIndexesIfNotInPanoramaPosition3","getBandSizeOfAxis","isCategoricalAxis","getStackSeriesIdentifier","selectChartBaseValue","selectXAxisIdFromGraphicalItemId","selectYAxisIdFromGraphicalItemId","selectXAxisWithScale","state","graphicalItemId","isPanorama","selectXAxisTicks","selectYAxisWithScale","selectYAxisTicks","selectBandSize","layout","xAxis","yAxis","xAxisTicks","yAxisTicks","pickAreaId","_state","id","selectSynchronisedAreaSettings","graphicalItems","filter","item","type","find","selectNumericalAxisType","isXAxisCategorical","selectNumericalAxisIdFromGraphicalItemId","axisType","selectNumericalAxisStackGroups","selectGraphicalItemStackedData","areaSettings","stackGroups","_stackGroups$stackId","undefined","stackId","stackSeriesIdentifier","groups","stackedData","found","v","key","map","selectArea","_ref","bandSize","chartBaseValue","chartData","dataStartIndex","dataEndIndex","length","data","displayedData","slice"],"sources":["C:/Users/Alex/OneDrive/Documents/Projects/Financial Planner/frontend/node_modules/recharts/es6/state/selectors/areaSelectors.js"],"sourcesContent":["import { createSelector } from 'reselect';\nimport { computeArea } from '../../cartesian/Area';\nimport { selectAxisWithScale, selectStackGroups, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectChartDataWithIndexesIfNotInPanoramaPosition3 } from './dataSelectors';\nimport { getBandSizeOfAxis, isCategoricalAxis } from '../../util/ChartUtils';\nimport { getStackSeriesIdentifier } from '../../util/stacks/getStackSeriesIdentifier';\nimport { selectChartBaseValue } from './rootPropsSelectors';\nimport { selectXAxisIdFromGraphicalItemId, selectYAxisIdFromGraphicalItemId } from './graphicalItemSelectors';\nvar selectXAxisWithScale = (state, graphicalItemId, isPanorama) => selectAxisWithScale(state, 'xAxis', selectXAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectXAxisTicks = (state, graphicalItemId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', selectXAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectYAxisWithScale = (state, graphicalItemId, isPanorama) => selectAxisWithScale(state, 'yAxis', selectYAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectYAxisTicks = (state, graphicalItemId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', selectYAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\nvar pickAreaId = (_state, id) => id;\n\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\nvar selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaId], (graphicalItems, id) => graphicalItems.filter(item => item.type === 'area').find(item => item.id === id));\nvar selectNumericalAxisType = state => {\n  var layout = selectChartLayout(state);\n  var isXAxisCategorical = isCategoricalAxis(layout, 'xAxis');\n  return isXAxisCategorical ? 'yAxis' : 'xAxis';\n};\nvar selectNumericalAxisIdFromGraphicalItemId = (state, graphicalItemId) => {\n  var axisType = selectNumericalAxisType(state);\n  if (axisType === 'yAxis') {\n    return selectYAxisIdFromGraphicalItemId(state, graphicalItemId);\n  }\n  return selectXAxisIdFromGraphicalItemId(state, graphicalItemId);\n};\nvar selectNumericalAxisStackGroups = (state, graphicalItemId, isPanorama) => selectStackGroups(state, selectNumericalAxisType(state), selectNumericalAxisIdFromGraphicalItemId(state, graphicalItemId), isPanorama);\nexport var selectGraphicalItemStackedData = createSelector([selectSynchronisedAreaSettings, selectNumericalAxisStackGroups], (areaSettings, stackGroups) => {\n  var _stackGroups$stackId;\n  if (areaSettings == null || stackGroups == null) {\n    return undefined;\n  }\n  var {\n    stackId\n  } = areaSettings;\n  var stackSeriesIdentifier = getStackSeriesIdentifier(areaSettings);\n  if (stackId == null || stackSeriesIdentifier == null) {\n    return undefined;\n  }\n  var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;\n  var found = groups === null || groups === void 0 ? void 0 : groups.find(v => v.key === stackSeriesIdentifier);\n  if (found == null) {\n    return undefined;\n  }\n  return found.map(item => [item[0], item[1]]);\n});\nexport var selectArea = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanoramaPosition3, selectBandSize, selectSynchronisedAreaSettings, selectChartBaseValue], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref, bandSize, areaSettings, chartBaseValue) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (areaSettings == null || layout !== 'horizontal' && layout !== 'vertical' || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n  var {\n    data\n  } = areaSettings;\n  var displayedData;\n  if (data && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n  if (displayedData == null) {\n    return undefined;\n  }\n  return computeArea({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataStartIndex,\n    areaSettings,\n    stackedData,\n    displayedData,\n    chartBaseValue,\n    bandSize\n  });\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}